#include <ultra64.h>
#include <macros.h>
#include <defines.h>
#include "camera.h"
#include "math_util_2.h"
#include "variables.h"
#include "audio/external.h"
#include "audio/load.h"
#include "audio/data.h"
#include <sounds.h>

// Requires void in the argument list to match properly.
void func_800C13F0(void) {
}

void func_800C13FC(OSMesg presetId) {
    OSMesg mesg;
    osRecvMesg(D_800EA3B4, &mesg, 0);
    osSendMesg(D_800EA3B0, presetId, 0);
    osRecvMesg(D_800EA3B4, &mesg, 1);
    if (mesg != presetId) {
        osRecvMesg(D_800EA3B4, &mesg, 1);
    }
}


f32 func_800C1480(u8 bank, u8 soundId) {
    f32 temp_f0;
    f32 var_f2;
    s32 var_v0;
    struct Unk_80191420 *temp_v0;

    temp_v0 = &sSoundBanks[bank][soundId];
    if (temp_v0->soundBits & 0x400000) {
        return 1.0f;
    }
    temp_f0 = temp_v0->distance;
    if (temp_f0 > 2000.0f) {
        var_f2 = 0.0f;
    } else {
        switch (temp_v0->soundBits & 0x30000) {                        /* irregular */
        case 0x10000:
            var_v0 = 0x1F4;
            break;
        case 0x20000:
            var_v0 = 0x29A;
            break;
        case 0x30000:
            var_v0 = 0x3E8;
            break;
        default:
            var_v0 = 0x190;
            break;
        }
        if (temp_f0 < var_v0) {
            var_f2 = (((var_v0 - temp_f0) / var_v0) * 0.5) + 0.5;
        } else {
            var_f2 = (1.0 - ((temp_f0 - var_v0) / (2000.0f - var_v0))) * 0.5;
        }
        var_f2 *= var_f2;
    }
    return var_f2;
}

s8 func_800C15D0(u8 bank, u8 soundId, u8 channel) {
    s32 var_a0;
    s8 var_v0;
    s8 var_v1;

    var_v0 = 0;
    var_v1 = 0;
    if (!(sSoundBanks[bank][soundId].soundBits & 0x200000)) {
        if (sSoundBanks[bank][soundId].distance < 500.0f) {
            var_v0 = (sSoundBanks[bank][soundId].distance / 500.0f) * 10.0f;
        } else {
            var_v0 = 0x0A;
        }
    }
    if (IS_SEQUENCE_CHANNEL_VALID(gSequencePlayers[2].channels[channel])) {
        var_v1 = gSequencePlayers[2].channels[channel]->soundScriptIO[6];
    }
    if (var_v1 == -1) {
        var_v1 = 0;
    }
    var_a0 = *sSoundBanks[bank][soundId].unk18 + var_v0 + var_v1 + D_8018EF10;
    if (var_a0 >= 0x80) {
        var_a0 = 0x7F;
    }
    return var_a0;
}

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
s8 D_800EA0F4 = 0;                                  /* const */
u8 D_800EA1C0 = 0;                                  /* const */

s8 func_800C16E8(f32 arg0, f32 arg1, u8 arg2) {
    f32 temp_f6;
    f32 var_f0;
    f32 var_f14;
    f32 var_f16;
    f32 var_f18;
    f32 var_f20;
    f32 var_f2;
    f32 var_f2_2;

    unksp-18.unk10 = (f64) saved_reg_f20;
    unksp-18.unk1C = arg1;
    unksp-18.unk20 = (s32) arg2;
    if (D_800EA1C0 == 0) {
        if ((u8) D_800EA0F4 != 0) {
            var_f16 = 10.0f;
            var_f14 = 20.0f;
            var_f18 = 2.5f;
            var_f2_2 = 10.0f;
        } else {
            var_f2_2 = 100.0f;
            var_f14 = 200.0f;
            var_f16 = 5.0f;
            var_f18 = 3.3333333f;
        }
        if (arg0 < 0.0f) {
            var_f20 = -arg0;
        } else {
            var_f20 = arg0;
        }
        if (var_f2_2 < var_f20) {
            var_f20 = var_f2_2;
        }
        temp_f6 = unksp-18.unk1C;
        if (temp_f6 < 0.0f) {
            var_f0 = -temp_f6;
        } else {
            var_f0 = unksp-18.unk1C;
        }
        if (var_f2_2 < var_f0) {
            var_f0 = var_f2_2;
        }
        if ((arg0 == 0.0f) && (unksp-18.unk1C == 0.0f)) {
            var_f2 = 0.5f;
        } else if ((arg0 >= 0.0f) && (var_f0 <= var_f20)) {
            var_f2 = 1.0f - ((var_f14 - var_f20) / (var_f16 * (var_f14 - var_f0)));
        } else if ((arg0 < 0.0f) && (var_f0 <= var_f20)) {
            var_f2 = (var_f14 - var_f20) / (var_f16 * (var_f14 - var_f0));
        } else {
            var_f2 = (arg0 / (var_f18 * var_f0)) + 0.5f;
        }
        if (var_f2 > 1.0f) {
            var_f2 = 1.0f;
        }
        if (var_f2 < 0.0f) {
            var_f2 = 0.0f;
        }
        return (s8) (s32) ((var_f2 * 127.0f) + 0.5f);
    }
    return (s8) ((arg2 & 0xFF & 1) * 0x7F);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C16E8.s")
#endif

f32 func_800C1934(u8 bank, u8 soundId) {
    f32 phi_f2;

    phi_f2 = 1.0f;
    if (sSoundBanks[bank][soundId].soundBits & 0x800000) {
        phi_f2 -= ((gAudioRandom & 0xF) / 192.0f);
    }
    return phi_f2;
}

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
s8 func_800C15D0(u8, u8, u8);                       /* extern */
s8 func_800C16E8(f32, f32, u8);                     /* extern */
? func_800CBB88(s32, f32);                          /* extern */
? func_800CBBE8(s32, s8);                           /* extern */
extern ? D_8018EF18;
extern ? D_80192C48;

void func_800C19D0(u8 arg0, u8 arg1, u8 arg2) {
    f32 sp3C;
    s8 sp3B;
    f32 sp34;
    s8 sp33;
    u8 temp_t6;
    void *temp_s0;
    void *temp_s0_2;

    temp_t6 = arg0 & 0xFF;
    sp3B = 0;
    sp33 = 0x40;
    sp3C = 1.0f;
    sp34 = 1.0f;
    switch (temp_t6) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
        temp_s0 = (temp_t6 * 0x3C0) + (arg1 * 0x30) + sSoundBanks;
        arg0 = temp_t6;
        temp_s0->unk1C = sqrtf(temp_s0->unk1C);
        sp3C = *(&D_80192C48 + (arg0 * 0x10)) * (func_800C1480(arg0, arg1) * *temp_s0->unk14);
        sp3B = func_800C15D0(arg0, arg1, arg2);
        sp34 = *temp_s0->unk10 * func_800C1934(arg0, arg1);
        sp33 = func_800C16E8(*temp_s0->unk0, *temp_s0->unk8, temp_s0->unkC);
        break;
    }
    temp_s0_2 = (arg2 * 0xC) + &D_8018EF18;
    if (sp3C != temp_s0_2->unk0) {
        func_800CBBE8(((arg2 & 0xFF) << 8) | 0x06020000 | 3, (s8) (u32) (sp3C * 127.0f));
        temp_s0_2->unk0 = sp3C;
    }
    if (sp3B != temp_s0_2->unk8) {
        func_800CBBE8((arg2 << 8) | 0x05020000, sp3B);
        temp_s0_2->unk8 = sp3B;
    }
    if (sp34 != temp_s0_2->unk4) {
        func_800CBB88((arg2 << 8) | 0x04020000, sp34);
        temp_s0_2->unk4 = sp34;
    }
    if (sp33 != temp_s0_2->unk9) {
        func_800CBBE8((arg2 << 8) | 0x03020000, sp33);
        temp_s0_2->unk9 = sp33;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C19D0.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
struct Unk_8018EFD8 *func_800C1C88(u8 arg0, f32 *position, f32 *velocity, f32 *arg3, u8 arg4, u32 soundBits) {
    struct Unk_8018EFD8 *temp_a1;
    struct Unk_8018EFD8 *temp_v1;
    u8 temp_a2;
    u8 temp_t7;
    u8 temp_v0;

    temp_v0 = D_8018FB90;
    temp_v1 = &D_8018EFD8[temp_v0];
    if (temp_v1->next != 0xFF) {
        temp_a2 = D_8018FB91;
        temp_a1 = &D_8018EFD8[temp_v0 & 0xFF];
        temp_a1->prev = temp_a2;
        D_8018EFD8[temp_a2].next = temp_v0;
        temp_t7 = temp_v1->next;
        D_8018FB91 = temp_v0;
        D_8018FB90 = temp_t7;
        D_8018EFD8[temp_t7 & 0xFF].prev = 0xFF;
        temp_a1->posY = position + 4;
        temp_a1->posX = position;
        temp_a1->posZ = position + 8;
        temp_a1->velX = velocity;
        temp_a1->velY = velocity + 4;
        temp_a1->next = 0xFF;
        temp_a1->velZ = velocity + 8;
        temp_a1->unk24 = arg3;
        temp_a1->unk18[1] = 0.0f;
        temp_a1->unk28 = arg4;
        temp_a1->unk30 = arg0;
        temp_a1->soundBits = soundBits;
        return temp_a1;
    }
    return NULL;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C1C88.s")
#endif

void func_800C1DA4(Camera *arg0, Vec3s arg1, struct Unk_8018EFD8 *arg2) {
    f32 temp_f12;
    f32 temp_f14;

    temp_f12 = arg0->pos[0] - *arg2->posX;
    temp_f14 = arg0->pos[2] - *arg2->posZ;
    arg2->unk18[0] = func_800416D8(temp_f12, temp_f14, arg1[1]);
    arg2->unk18[2] = func_80041724(temp_f12, temp_f14, arg1[1]);
}

void func_800C1E2C(Camera *camera, Vec3f arg1, struct Unk_8018EFD8 *arg2) {
    f32 sp44;
    f32 temp_f6;
    f32 temp_f16;
    f32 temp_f18;
    f32 dist0;
    f32 dist1;
    f32 thing0;
    f32 thing1;
    f32 temp_f2;

    temp_f16 = (*arg2->posX) - camera->pos[0];
    temp_f18 = (*arg2->posZ) - camera->pos[2];

    sp44 = (*arg2->velX) - arg1[0];
    temp_f6 = (*arg2->velZ) - arg1[2];

    thing0 = temp_f16 + sp44;
    thing1 = temp_f18 + temp_f6;

    dist0 = sqrtf((temp_f16 * temp_f16) + (temp_f18 * temp_f18));
    dist1 = sqrtf((thing0 * thing0) + (thing1 * thing1));

    temp_f2 = 1.0f / (1.0f - ((dist0 - dist1) / arg2->unk34));

    if (temp_f2 > 0.1f) {
        arg2->unk2C = temp_f2;
    } else {
        arg2->unk2C = 0.1f;
    }

    if ((*arg2->unk24) != 0.0f) {
        arg2->unk2C *= (((*arg2->unk24) / D_800EA06C[arg2->unk30].unk00[1]) + D_800EA06C[arg2->unk30].unk00[0]) + D_800E9F34[arg2->unk30];
    }
}

void func_800C1F8C(void) {
    u8 var_s1;
    u8 var_a1;
    u8 cameraId;
    Camera **camera;

    var_a1 = D_800EA1C0 + 1;
    for (var_s1 = 0; var_s1 < var_a1; var_s1++) {
        D_8018FBA8[var_s1][0] = D_8018FB98[var_s1]->pos[0] - D_8018FBD8[var_s1][0];
        D_8018FBA8[var_s1][2] = D_8018FB98[var_s1]->pos[2] - D_8018FBD8[var_s1][2];
        D_8018FBD8[var_s1][0] = D_8018FB98[var_s1]->pos[0];
        D_8018FBD8[var_s1][2] = D_8018FB98[var_s1]->pos[2];
    }

    var_a1 = 0;
    var_s1 = D_8018EFD8[0].next;
    while (var_s1 != 0xFF) {
        if (D_8018EFD8[var_s1].unk18[1] == 100000.0f) {
            if (D_8018FB91 == var_s1) {
                D_8018FB91 = D_8018EFD8[var_s1].prev;
            } else {
                D_8018EFD8[D_8018EFD8[var_s1].next].prev = D_8018EFD8[var_s1].prev;
            }
            D_8018EFD8[D_8018EFD8[var_s1].prev].next = D_8018EFD8[var_s1].next;
            D_8018EFD8[var_s1].prev = 0xFF;
            D_8018EFD8[var_s1].next = D_8018FB90;
            D_8018EFD8[D_8018FB90].prev = var_s1;
            D_8018FB90 = var_s1;
        } else {
            cameraId = D_8018EFD8[var_s1].cameraId;
            // Why? Why would you do it this way? For what possible reason?
            camera = &D_8018FB98[cameraId];
            func_800C1DA4(*camera, (*camera)->rot, &D_8018EFD8[var_s1]);
            if (D_800EA1C8 != D_8018EFD8[var_s1].velX) {
                func_800C1E2C(*camera, D_8018FBA8[0], &D_8018EFD8[var_s1]);
            }
            var_a1 = var_s1;
        }
        var_s1 = D_8018EFD8[var_a1].next;
        if ((var_s1 != 0xFF) && (D_800EA244 < var_s1)) {
            D_800EA244 = var_s1;
        }
    }
}

f32 *func_800C21E8(Vec3f arg0, u32 arg1) {
    u8 var_v0;
    f32 *ret;
    // Only here to force a match
    f32 *thing = arg0;
    struct Unk_8018EFD8 *temp_a1;

    ret = 0;
    var_v0 = D_8018EFD8[0].next;
    while (var_v0 != 0xFF) {
        temp_a1 = &D_8018EFD8[var_v0];
        // It doesn't matter what you set var_v0 to here actually
        var_v0 = D_8018EFD8[0].next;
        if ((arg0 == temp_a1->posX) && (arg1 == temp_a1->soundBits)) {
            // I suspect all this weirdness here is a result of someone not knowing the 'break' keyword
            var_v0 = 0xFF;
            if (temp_a1->unk18[1] != 100000.0f) {
                ret = temp_a1->unk18;
            } else {
                goto test;
            }
        } else {
            test:
            var_v0 = temp_a1->next;
        }
    }
    return ret;
}

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_8001AAAC(s16, s16, s16);                     /* extern */
? func_800CBBE8(s32, ?, s32, s32);                  /* extern */
extern ? D_8018FC10;

void func_800C2274(s32 player) {
    s16 sp46;
    s16 sp44;
    s16 sp42;
    s16 temp_a1;
    s16 temp_t2;
    s16 var_s0;
    s16 var_s1;
    s32 temp_a3;
    s32 temp_v0;
    s32 var_a2;
    struct SequenceChannel *temp_v0_2;
    u8 temp_s0;
    void *temp_s1;
    void *temp_v0_3;
    void *temp_v0_4;

    temp_a3 = player & 0xFF;
    var_a2 = 0xF;
    if (((u32) gSequencePlayers[temp_a3] >> 0x1F) != 0) {
        temp_v0 = gScreenModeSelection;
        switch (temp_v0) {                          /* irregular */
        case 0:
            break;
        case 1:
            var_a2 = 0xE;
            break;
        case 3:
            var_a2 = 0xC;
            if (gPlayerCountSelection1 == 3) {
                var_a2 = 0xD;
            }
            break;
        }
        temp_v0_2 = gSequencePlayers[temp_a3].channels[var_a2];
        temp_s0 = (u8) temp_v0_2->soundScriptIO[0];
        if (temp_s0 != (u8) 0x00FF) {
            sp46 = temp_v0_2->soundScriptIO[1] & 3;
            var_s1 = temp_v0_2->soundScriptIO[2] & 0xF;
            if (var_s1 >= 0xA) {
                var_s1 = 9;
            }
            sp42 = temp_v0_2->soundScriptIO[3] & 7;
            func_800CBBE8(((temp_a3 & 0xFF) << 0x10) | 0x06000000 | ((var_a2 & 0xFF) << 8), -1, var_a2, temp_a3);
            sp44 = var_s1;
        }
        switch (temp_s0) {                          /* switch 1; irregular */
        case 1:                                     /* switch 1 */
            temp_v0_3 = &D_8018FC10 + (sp46 * 4);
            temp_v0_3->unk0 = sp44;
            var_s0 = 0;
            temp_v0_3->unk2 = sp42;
            do {
                temp_s1 = &D_8018FC10 + (var_s0 * 4);
                temp_a1 = temp_s1->unk0;
                if (temp_a1 != 0x00FF) {
                    func_8001AAAC(var_s0, temp_a1, temp_s1->unk2);
                    temp_s1->unk0 = 0x00FF;
                }
                temp_t2 = (var_s0 + 1) & 0xFF;
                var_s0 = temp_t2;
            } while (temp_t2 < 4);
            return;
        case 2:                                     /* switch 1 */
            temp_v0_4 = &D_8018FC10 + (sp46 * 4);
            temp_v0_4->unk0 = sp44;
            temp_v0_4->unk2 = sp42;
            break;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C2274.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
struct _struct_D_800EA06C_0x10 {
    /* 0x00 */ char pad0[0xC];
    /* 0x0C */ s8 unkC;                             /* inferred */
    /* 0x0D */ char padD[3];                        /* maybe part of unkC[4]? */
};                                                  /* size = 0x10 */

? func_800CBBB8(?, ?);                              /* extern */
extern s8 D_8018EF10;
extern ? D_8018EF18;
extern ? D_8018FB98;
extern ? D_8018FBA8;
extern ? D_8018FBD8;
extern s8 D_8018FC08;
extern ? D_8018FC10;
static s32 D_800E9DB4[4] = { 0, 0, 0, 0 };          /* const */
static ?32 D_800E9DF4[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; /* const */
static s32 D_800E9E74[4] = { 0, 0, 0, 0 };          /* const */
static s32 D_800E9E84[4] = { 0, 0, 0, 0 };          /* const */
static s32 D_800E9E94[4] = { 0, 0, 0, 0 };          /* const */
static s32 D_800E9EA4[4] = { 0, 0, 0, 0 };          /* const */
static ? D_800E9F24;                                /* unable to generate initializer; const */
static ? D_800E9F2C;                                /* unable to generate initializer; const */
static f32 D_800E9F34[8] = { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static f32 D_800E9F54[8] = { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static ? D_800E9F74;                                /* unable to generate initializer; const */
static ? D_800E9F78;                                /* unable to generate initializer; const */
static ? D_800E9F7C;                                /* unable to generate initializer; const */
static struct _struct_D_800EA06C_0x10 D_800EA06C[0]; /* unable to generate initializer; const */
static ? D_800EA0EC;                                /* unable to generate initializer; const */
static s8 D_800EA0F0 = 0;                           /* const */
static s8 D_800EA104 = 0;                           /* const */
static ? D_800EA10C;                                /* unable to generate initializer; const */
static f32 D_800EA130[8] = { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static s16 D_800EA15C = 0;                          /* const */
static s16 D_800EA160 = 0;                          /* const */
static s8 D_800EA164 = 0;                           /* const */
static s8 D_800EA16C = 0;                           /* const */
static s16 D_800EA180 = 0;                          /* const */
static s16 D_800EA184 = 0;                          /* const */
s8 D_800EA0F4 = 0;                                  /* const */
s8 D_800EA108 = 0;                                  /* const */

void func_800C2474(void) {
    Player *temp_a2;
    Player *temp_t7;
    s32 temp_at;
    s32 temp_at_2;
    s32 temp_lo;
    s32 temp_lo_2;
    s32 temp_lo_3;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_t6_3;
    s32 temp_t8;
    s32 var_v0;
    s32 var_v0_2;
    s32 var_v0_3;
    s32 var_v0_4;
    s32 var_v1;
    s8 temp_t8_2;
    s8 temp_t9;
    struct Unk_8018EFD8 *temp_a0_4;
    void *temp_a0;
    void *temp_a0_2;
    void *temp_a0_3;
    void *temp_a1;
    void *temp_v1;

    D_8018EF10 = 0;
    D_8018FB98.unk0 = (Camera *) camera1;
    D_8018FB98.unk4 = (Camera *) camera2;
    D_8018FB98.unk8 = (Camera *) camera3;
    D_8018FB98.unkC = (Camera *) camera4;
    D_8018FB91 = 0;
    D_8018FB90 = 1;
    D_800EA0F4 = 0;
    D_8018FC08 = 0;
    D_800EA104 = 0;
    D_800EA108 = 0;
    D_800EA0F0 = 0;
    D_800EA16C = 0;
    func_800CBBB8(0xF2000000, 0);
    D_800EA16C = 0;
    D_800EA15C = 0;
    D_800EA160 = 0;
    D_800EA164 = 0;
    D_800EA178 = 1.0f;
    D_800EA17C = 0.85f;
    D_800EA180 = 0;
    D_800EA184 = 0;
    var_v0 = 0;
    do {
        temp_lo = var_v0 * 0xC;
        D_800E9DB4[var_v0] = 0;
        D_800E9DF4[var_v0] = 0;
        *(&D_800EA0EC + var_v0) = 0;
        D_800E9EA4[var_v0] = 0;
        temp_a0 = &D_8018FBA8 + temp_lo;
        temp_a1 = &D_8018FBD8 + temp_lo;
        temp_a0->unk0 = 0.0f;
        temp_a0->unk4 = 0.0f;
        temp_a0->unk8 = 0.0f;
        temp_a1->unk0 = 0.0f;
        temp_a1->unk4 = 0.0f;
        temp_a1->unk8 = 0.0f;
        temp_a0_2 = &D_8018FC10 + (var_v0 * 4);
        (&D_800E9F7C + (var_v0 * 0x3C))->unk14 = 0;
        D_800E9E74[var_v0] = 0;
        D_800E9E84[var_v0] = 0;
        D_800E9E94[var_v0] = 0;
        temp_a2 = &gPlayers[var_v0];
        temp_a2->boundingBoxCorners[2].surfaceType = 0;
        temp_a2->boundingBoxCorners[3].surfaceType = 0;
        temp_a2->unk_0BC = 0;
        temp_a2->unk_20C = 0.0f;
        temp_a2->unk_0C0 = 0;
        temp_a2->unk_098 = 0.0f;
        temp_a2->unk_0DE = 0;
        temp_a0_2->unk0 = 0x00FF;
        temp_a0_2->unk2 = 0;
        *(&D_800EA10C + var_v0) = 0;
        *(&D_800E9F74 + var_v0) = 0;
        temp_t6 = (var_v0 + 1) & 0xFF;
        *(&D_800E9F78 + var_v0) = 0;
        var_v0 = temp_t6;
    } while (temp_t6 < 4);
    var_v0_2 = 0;
    do {
        *(&D_800E9F24 + var_v0_2) = 0;
        *(&D_800E9F2C + var_v0_2) = 0;
        D_800E9F34[var_v0_2] = 0.0f;
        D_800E9F54[var_v0_2] = 0.0f;
        D_800EA130[var_v0_2] = 0.0f;
        temp_t8 = (var_v0_2 + 1) & 0xFF;
        temp_at = temp_t8 < 8;
        D_800EA06C[var_v0_2].unkC = 0;
        temp_t7 = &gPlayers[var_v0_2];
        var_v0_2 = temp_t8;
        temp_t7->unk_0BC = 0;
    } while (temp_at != 0);
    var_v0_3 = 0;
    do {
        temp_lo_2 = var_v0_3 * 0xC;
        temp_t6_2 = (var_v0_3 + 1) & 0xFF;
        temp_at_2 = temp_t6_2 < 0x10;
        var_v0_3 = temp_t6_2;
        temp_v1 = &D_8018EF18 + temp_lo_2;
        temp_v1->unk0 = 1.0f;
        temp_v1->unk4 = 1.0f;
        temp_v1->unk8 = 0;
        temp_v1->unk9 = 0x40;
    } while (temp_at_2 != 0);
    D_8018EFD8->prev = 0xFF;
    D_8018EFD8->next = 0xFF;
    var_v0_4 = 1;
    var_v1 = 1;
    do {
        temp_lo_3 = var_v0_4 * 0x3C;
        temp_t6_3 = (var_v0_4 + 1) & 0xFF;
        temp_t8_2 = var_v1 - 1;
        temp_t9 = var_v1 + 1;
        var_v1 = temp_t6_3;
        var_v0_4 = temp_t6_3;
        temp_a0_3 = D_8018EFD8 + temp_lo_3;
        temp_a0_3->unk29 = temp_t8_2;
        temp_a0_3->unk2A = temp_t9;
    } while (temp_t6_3 < 0x31);
    temp_a0_4 = &D_8018EFD8[temp_t6_3];
    temp_a0_4->prev = temp_t6_3 - 1;
    temp_a0_4->next = 0xFF;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C2474.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800CBB88(s32, f32, void *); // extern
void func_800CBBB8(s32, s32, s32); // extern
extern u8 D_800EA1EC;
extern ? D_801930D0;

void func_800C284C(u8 arg0, u8 arg1, u8 arg2, s32 arg3) {
    s32 sp34;
    void *sp30;
    f32 temp_f2;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_t6_3;
    s32 temp_v0;
    void *temp_a2;
    void *temp_v0_2;
    s32 phi_v1;

    temp_t6 = arg3 & 0xFFFF;
    if ((D_800EA1EC == 0) || (arg0 == 2)) {
        temp_v0 = arg0 << 0x10;
        sp34 = temp_v0;
        func_800CBBB8(temp_v0 | 0x82000000 | (arg1 << 8), temp_t6, temp_t6);
        temp_t6_2 = arg0 * 0x24C;
        temp_a2 = temp_t6_2 + &D_801930D0;
        temp_f2 = temp_a2->unk0;
        temp_a2->unk248 = arg1 | (arg2 << 8);
        if (temp_f2 != 1.0f) {
            sp30 = temp_a2;
            func_800CBB88(temp_v0 | 0x41000000, temp_f2, temp_a2);
        }
        (temp_t6_2 + &D_801930D0)->unk28 = 0;
        (temp_t6_2 + &D_801930D0)->unk18 = 0;
        (temp_t6_2 + &D_801930D0)->unk14 = 0;
        phi_v1 = 0;
        do {
            temp_v0_2 = (arg0 * 0x24C) + &D_801930D0 + (phi_v1 << 5);
            temp_t6_3 = (phi_v1 + 1) & 0xFF;
            temp_v0_2->unk44 = 1.0f;
            temp_v0_2->unk50 = 0;
            temp_v0_2->unk54 = 1.0f;
            temp_v0_2->unk60 = 0;
            phi_v1 = temp_t6_3;
        } while (temp_t6_3 < 0x10);
        (temp_t6_2 + &D_801930D0)->unk244 = 0;
        (temp_t6_2 + &D_801930D0)->unk246 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C284C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800CBBB8(s32, s32); // extern
extern ? D_80193318;

void func_800C29B4(u8 arg0, s32 arg1) {
    func_800CBBB8((arg0 << 0x10) | 0x83000000, arg1 & 0xFFFF);
    *(&D_80193318 + (arg0 * 0x24C)) = 0xFFFF;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C29B4.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C13FC(s32, s32);                          /* extern */
? func_800C284C(u8, u8, u8, u32);                   /* extern */
? func_800C29B4(u8, s32);                           /* extern */
? func_800C5C40();                                  /* extern */
? func_800CBBB8(?, u8);                             /* extern */
? func_800CBBE8(s32, s8, s8, s32);                  /* extern */
extern ? D_80192CA8;
extern ? D_80192CC6;
extern ? D_801930D0;
static s8 D_800EA1C0 = 0;                           /* const */
static s8 D_800EA1EC = 0;                           /* const */
static ? D_800EA1F0;                                /* unable to generate initializer; const */
static s8 D_800EA1F4[0x4]; /* const */

void func_800C2A2C(u16 arg0, void *arg2) {
    u8 sp5B;
    u32 sp4C;
    s32 sp48;
    s32 sp44;
    s32 sp3C;
    u8 *sp34;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f2;
    f32 temp_f4;
    f32 var_f16;
    f32 var_f8;
    s16 var_a1;
    s16 var_a1_3;
    s32 temp_a0;
    s32 temp_a0_4;
    s32 temp_a0_5;
    s32 temp_a1;
    s32 temp_a2_3;
    s32 temp_a2_4;
    s32 temp_a3;
    s32 temp_a3_3;
    s32 temp_at;
    s32 temp_at_2;
    s32 temp_t6_2;
    s32 temp_t7_2;
    s32 temp_t8_2;
    s32 temp_t8_3;
    s32 temp_t8_4;
    s32 temp_t8_5;
    s32 temp_t8_6;
    s32 temp_t8_8;
    s32 temp_v0_7;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 var_a3;
    s32 var_t0;
    s32 var_v0;
    s32 var_v0_2;
    s32 var_v1;
    s32 var_v1_2;
    s32 var_v1_3;
    s32 var_v1_4;
    s32 var_v1_5;
    s8 temp_a2_5;
    s8 var_a2;
    u32 temp_a3_2;
    u32 temp_t6;
    u32 temp_t6_3;
    u32 temp_t7;
    u32 temp_t8;
    u32 temp_t8_7;
    u32 temp_t9_2;
    u32 var_a0;
    u32 var_a1_2;
    u8 *temp_t4;
    u8 *temp_t4_2;
    u8 temp_t0;
    u8 temp_t1;
    u8 temp_t1_2;
    u8 temp_t9;
    u8 var_t0_2;
    u8 var_t3;
    u8 var_v1_6;
    void *temp_a0_2;
    void *temp_a0_3;
    void *temp_a1_2;
    void *temp_a1_3;
    void *temp_a2;
    void *temp_a2_2;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;
    void *temp_v0_8;
    void *temp_v1_4;

    temp_t8 = (arg0 >> 0x1C) & 0xFF;
    temp_t6 = (u32) (arg0 & 0x0F000000) >> 0x18;
    temp_a1 = temp_t6 & 0xFF;
    switch (temp_t8) {
    case 0:
        func_800C284C(temp_t6 & 0xFF, arg0 & 0xFF, ((u32) (arg0 & 0xFF00) >> 8) & 0xFF, ((u32) (arg0 & 0xFF0000) >> 0xD) & 0xFFFF);
        return;
    case 1:
        func_800C29B4(temp_t6 & 0xFF, ((u32) (arg0 & 0xFF0000) >> 0xD) & 0xFFFF);
        return;
    case 2:
        temp_t8_2 = temp_t6 & 0xFF;
        temp_t4 = &D_80192CC6 + temp_t8_2;
        sp3C = temp_t8_2;
        temp_t1 = *temp_t4;
        var_v1 = 0;
        var_t3 = temp_t1;
        if ((s32) temp_t1 > 0) {
            temp_a0 = arg0 & 0xFF;
            sp48 = temp_a0;
loop_6:
            if (temp_a0 == *((temp_t8_2 * 0xA) + &D_80192CA8 + (var_v1 * 2))) {
                if (var_v1 == 0) {
                    func_800C284C(unksp3F, unksp4B, ((u32) (arg0 & 0xFF00) >> 8) & 0xFF, ((u32) (arg0 & 0xFF0000) >> 0xD) & 0xFFFF);
                    return;
                }
            } else {
                temp_t6_2 = (var_v1 + 1) & 0xFF;
                var_v1 = temp_t6_2;
                if (temp_t6_2 >= (s32) *(&D_80192CC6 + temp_a1)) {
                    var_v1 = 0;
                    goto block_11;
                }
                goto loop_6;
            }
        } else {
block_11:
            var_t0 = temp_t1 & 0xFF;
            if ((s32) var_t3 > 0) {
                do {
                    if ((((u32) (arg0 & 0xFF00) >> 8) & 0xFF) >= (s32) ((sp3C * 0xA) + &D_80192CA8 + (var_v1 * 2))->unk1) {
                        var_t0 = var_v1 & 0xFF;
                        var_v1 = temp_t1 & 0xFF;
                    }
                    temp_t8_3 = (var_v1 + 1) & 0xFF;
                    var_v1 = temp_t8_3;
                } while (temp_t8_3 < (s32) *(&D_80192CC6 + temp_a1));
            }
            if ((var_t0 != var_t3) || (var_t0 == 0)) {
                temp_a2 = (sp3C * 0xA) + &D_80192CA8;
                if ((s32) var_t3 < 5) {
                    temp_t9 = temp_t1 + 1;
                    *temp_t4 = temp_t9;
                    var_t3 = temp_t9 & 0xFF;
                }
                var_v0 = (var_t3 - 1) & 0xFF;
                var_v1_2 = var_v0;
                if (var_t0 != var_v0) {
                    do {
                        temp_a1_2 = temp_a2 + (var_v0 * 2);
                        temp_a0_2 = temp_a2 + (var_v1_2 * 2);
                        temp_a0_2->unk1 = (u8) temp_a1_2->unk-1;
                        var_v0 = (var_v1_2 - 1) & 0xFF;
                        var_v1_2 = var_v0;
                        temp_a0_2->unk0 = (u8) temp_a1_2->unk-2;
                    } while (var_t0 != var_v0);
                }
                temp_v0 = temp_a2 + (var_t0 * 2);
                temp_v0->unk1 = (s8) (((u32) (arg0 & 0xFF00) >> 8) & 0xFF);
                temp_v0->unk0 = (s8) (arg0 & 0xFF);
            }
            if (var_t0 == 0) {
                func_800C284C(unksp3F, arg0 & 0xFF, ((u32) (arg0 & 0xFF00) >> 8) & 0xFF, ((u32) (arg0 & 0xFF0000) >> 0xD) & 0xFFFF);
                return;
            }
        default:
            return;
        }
        break;
    case 3:
        temp_t8_4 = temp_t6 & 0xFF;
        temp_t4_2 = &D_80192CC6 + temp_t8_4;
        sp3C = temp_t8_4;
        temp_t1_2 = *temp_t4_2;
        var_v1_3 = 0;
        var_t0_2 = temp_t1_2;
        if ((s32) temp_t1_2 > 0) {
            do {
                if ((arg0 & 0xFF) == *((temp_t8_4 * 0xA) + &D_80192CA8 + (var_v1_3 * 2))) {
                    var_t0_2 = var_v1_3 & 0xFF;
                    var_v1_3 = temp_t1_2 & 0xFF;
                }
                temp_t8_5 = (var_v1_3 + 1) & 0xFF;
                var_v1_3 = temp_t8_5;
            } while (temp_t8_5 < (s32) *(&D_80192CC6 + temp_a1));
        }
        if (var_t0_2 != temp_t1_2) {
            temp_a3 = temp_t1_2 - 1;
            var_v1_4 = var_t0_2 & 0xFF;
            if ((s32) var_t0_2 < temp_a3) {
                temp_a2_2 = (sp3C * 0xA) + &D_80192CA8;
                var_v0_2 = var_v1_4;
                do {
                    temp_a1_3 = temp_a2_2 + (var_v0_2 * 2);
                    temp_a0_3 = temp_a2_2 + (var_v1_4 * 2);
                    temp_a0_3->unk1 = (u8) temp_a1_3->unk3;
                    var_v0_2 = (var_v1_4 + 1) & 0xFF;
                    var_v1_4 = var_v0_2;
                    temp_a0_3->unk0 = (u8) temp_a1_3->unk2;
                } while (var_v0_2 < temp_a3);
            }
            *temp_t4_2 = temp_t1_2 - 1;
        }
        if (var_t0_2 == 0) {
            temp_a3_2 = ((u32) (arg0 & 0xFF0000) >> 0xD) & 0xFFFF;
            sp4C = temp_a3_2;
            sp34 = temp_t4_2;
            func_800C29B4(unksp3F, temp_a3_2 & 0xFFFF);
            if (*temp_t4_2 != 0) {
                temp_v0_2 = (sp3C * 0xA) + &D_80192CA8;
                func_800C284C((u8) sp3C, temp_v0_2->unk0, temp_v0_2->unk1, temp_a3_2);
                return;
            }
        }
        break;
    case 4:
        temp_t9_2 = (u32) (arg0 & 0xFF0000) >> 0xF;
        temp_v1 = temp_t9_2 & 0xFF;
        var_a1 = temp_t9_2 & 0xFF;
        if (temp_v1 == 0) {
            var_a1 = (temp_v1 + 1) & 0xFF;
        }
        temp_v0_3 = &D_801930D0 + ((temp_t6 & 0xFF) * 0x24C);
        temp_f2 = temp_v0_3->unk0;
        temp_f0 = (f32) (arg0 & 0xFF) / 127.0f;
        temp_v0_3->unk4 = temp_f0;
        if (temp_f2 != temp_f0) {
            var_f8 = (f32) var_a1;
            if (var_a1 < 0) {
                var_f8 += 4294967296.0f;
            }
            temp_v0_3->unkC = var_a1;
            temp_v0_3->unk8 = (f32) ((temp_f2 - temp_v0_3->unk4) / var_f8);
            return;
        }
        break;
    case 5:
        temp_t7 = (u32) (arg0 & 0xFF0000) >> 0xF;
        temp_v1_2 = temp_t7 & 0xFF;
        var_a1_2 = temp_t7 & 0xFF;
        if (temp_v1_2 == 0) {
            var_a1_2 = (temp_v1_2 + 1) & 0xFF;
        }
        var_v1_5 = 0;
        temp_a2_3 = temp_t6 & 0xFF;
        temp_f0_2 = (f32) (arg0 & 0xFFFF) / 1000.0f;
        do {
            temp_v0_4 = (temp_a2_3 * 0x24C) + &D_801930D0 + (var_v1_5 << 5);
            temp_t8_6 = (var_v1_5 + 1) & 0xFF;
            temp_f4 = temp_v0_4->unk54 - temp_f0_2;
            temp_at = temp_t8_6 < 0x10;
            var_v1_5 = temp_t8_6;
            temp_v0_4->unk58 = temp_f0_2;
            temp_v0_4->unk60 = (s16) var_a1_2;
            temp_v0_4->unk5C = (f32) (temp_f4 / (f32) var_a1_2);
        } while (temp_at != 0);
        (&D_801930D0 + (temp_a2_3 * 0x24C))->unk244 = 0xFFFF;
        return;
    case 6:
        temp_t8_7 = (u32) (arg0 & 0xFF0000) >> 0xF;
        temp_v1_3 = temp_t8_7 & 0xFF;
        var_a1_3 = temp_t8_7 & 0xFF;
        if (temp_v1_3 == 0) {
            var_a1_3 = (temp_v1_3 + 1) & 0xFF;
        }
        temp_a3_3 = temp_t6 & 0xFF;
        temp_a2_4 = ((u32) (arg0 & 0xF00) >> 8) & 0xFF;
        temp_a0_4 = temp_a2_4 << 5;
        temp_v0_5 = &D_801930D0 + (temp_a3_3 * 0x24C) + temp_a0_4;
        temp_f0_3 = (f32) (arg0 & 0xFF) / 127.0f;
        temp_v0_5->unk48 = temp_f0_3;
        if (temp_v0_5->unk44 != temp_f0_3) {
            temp_v0_6 = &D_801930D0 + (temp_a3_3 * 0x24C);
            temp_v1_4 = temp_v0_6 + temp_a0_4;
            var_f16 = (f32) var_a1_3;
            if (var_a1_3 < 0) {
                var_f16 += 4294967296.0f;
            }
            temp_v1_4->unk50 = var_a1_3;
            temp_v1_4->unk4C = (f32) ((temp_v1_4->unk44 - temp_v1_4->unk48) / var_f16);
            temp_v0_6->unk244 = (u16) (temp_v0_6->unk244 | (1 << temp_a2_4));
            return;
        }
        break;
    case 7:
        func_800CBBE8(((temp_t6 & 0xFF) << 0x10) | 0x46000000 | ((((u32) (arg0 & 0xFF0000) >> 0x10) & 0xFF) << 8), (s8) arg0);
        return;
    case 8:
        temp_v0_7 = temp_t6 & 0xFF;
        temp_a2_5 = ((u32) (arg0 & 0xF00) >> 8) & 0xFF;
        if (!((&D_801930D0 + (temp_v0_7 * 0x24C))->unk24A & (1 << temp_a2_5))) {
            func_800CBBE8(((temp_v0_7 & 0xFF) << 0x10) | 0x06000000 | ((temp_a2_5 & 0xFF) << 8) | (((u32) (arg0 & 0xFF0000) >> 0x10) & 0xFF), (s8) arg0, temp_a2_5);
            return;
        }
        break;
    case 9:
        (&D_801930D0 + ((temp_t6 & 0xFF) * 0x24C))->unk24A = arg0;
        return;
    case 10:
        var_a0 = 1;
        sp48 = ((temp_t6 & 0xFF) << 0x10) | 0x08000000;
        var_a3 = arg0 & 0xFFFF;
        var_v1_6 = 0;
        do {
            if (var_a3 & var_a0) {
                var_a2 = 1;
            } else {
                var_a2 = 0;
            }
            sp4C = var_a0;
            sp5B = var_v1_6;
            sp44 = var_a3;
            func_800CBBE8(sp48 | ((var_v1_6 & 0xFF) << 8), var_a2, var_a2, var_a3);
            temp_t8_8 = (var_v1_6 + 1) & 0xFF;
            temp_at_2 = temp_t8_8 < 0x10;
            var_v1_6 = (u8) temp_t8_8;
            var_a0 = (var_a0 * 2) & 0xFFFF;
        } while (temp_at_2 != 0);
        return;
    case 11:
        (&D_801930D0 + ((temp_t6 & 0xFF) * 0x24C))->unk14 = (s32) arg0;
        return;
    case 12:
        if ((((u32) (arg0 & 0xF00000) >> 0x14) & 0xFF) != 0xF) {
            temp_v0_8 = &D_801930D0 + ((temp_t6 & 0xFF) * 0x24C);
            temp_t0 = temp_v0_8->unk41;
            temp_v0_8->unk41 = (u8) (temp_t0 + 1);
            if ((s32) temp_t0 < 5) {
                (temp_v0_8 + (temp_t0 * 4))->unk2C = (s32) arg0;
                temp_v0_8->unk40 = 2;
                return;
            }
        } else {
            (&D_801930D0 + ((temp_t6 & 0xFF) * 0x24C))->unk41 = 0;
            return;
        }
        break;
    case 14:
        temp_t7_2 = ((u32) (arg0 & 0xF00) >> 8) & 0xFF;
        switch (temp_t7_2) {                        /* switch 1; irregular */
        case 0:                                     /* switch 1 */
            func_800CBBB8(0xF0000000, *(&D_800EA1F0 + (arg0 & 0xFF)));
            return;
        case 1:                                     /* switch 1 */
            D_800EA1EC = arg0 & 1;
            return;
        }
        break;
    case 15:
        temp_t6_3 = (u32) (arg0 & 0xFF00) >> 8;
        D_800EA1C0 = (s8) temp_t6_3;
        temp_a0_5 = arg0 & 0xFF;
        sp48 = temp_a0_5;
        sp4C = temp_t6_3;
        func_800C13FC(temp_a0_5, temp_a1);
        *D_800EA1F4 = (s8) sp48;
        func_800CBBE8(0x46020000, (s8) sp4C);
        func_800C5C40();
        break;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C2A2C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern u8 D_800EA1E4;
extern ? D_80192CD0;

void func_800C3448(s32 arg0) {
    u8 temp_v0;

    temp_v0 = D_800EA1E4;
    *(&D_80192CD0 + (temp_v0 * 4)) = arg0;
    D_800EA1E4 = temp_v0 + 1;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C3448.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C2A2C(s32); // extern
extern u8 D_800EA1E4;
extern u8 D_800EA1E8;
extern ? D_80192CD0;

void func_800C3478(void) {
    if (D_800EA1E8 != D_800EA1E4) {
        do {
            D_800EA1E8 = D_800EA1E8 + 1;
            func_800C2A2C(*(&D_80192CD0 + (D_800EA1E8 * 4)));
        } while (D_800EA1E8 != D_800EA1E4);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C3478.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
extern ? D_80193318;

u16 func_800C3508(s32 player) {
    s32 temp_t6;

    temp_t6 = player & 0xFF;
    unksp-10.unk10 = player;
    if (((u32) gSequencePlayers[temp_t6] >> 0x1F) == 0) {
        return 0xFFFFU;
    }
    return *(&D_80193318 + (temp_t6 * 0x24C));
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C3508.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern u8 D_800EA1E4;
extern u8 D_800EA1E8;
extern ? D_80192CD0;

s32 func_800C357C(s32 arg0) {
    ? sp-10;
    s32 temp_t9;
    u8 temp_a1;
    u8 temp_v0;
    u8 phi_v0;
    u8 phi_v0_2;
    ? phi_v1;
    ? phi_v1_2;

    temp_a1 = D_800EA1E4;
    temp_v0 = D_800EA1E8;
    phi_v0 = temp_v0;
    phi_v1 = 1;
    phi_v1_2 = 1;
    if (temp_v0 < temp_a1) {
        do {
            phi_v0_2 = phi_v0;
            if (arg0 == *(&D_80192CD0 + (phi_v0 * 4))) {
                phi_v0_2 = temp_a1 & 0xFF;
                phi_v1_2 = 0;
            }
            temp_t9 = (phi_v0_2 + 1) & 0xFF;
            phi_v0 = temp_t9;
            phi_v1 = phi_v1_2;
        } while (temp_t9 < temp_a1);
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C357C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80192CC6;

void func_800C35E8(s32 arg0) {
    *(&D_80192CC6 + (arg0 & 0xFF)) = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C35E8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_801930D0;

void func_800C3608(s32 arg0, s32 arg1) {
    ? sp-10;
    s32 temp_t6;
    s32 temp_t9;
    u8 temp_a2;
    void *temp_a3;
    void *temp_v1;
    s32 phi_v0;
    s32 phi_a2;

    temp_t6 = arg0 & 0xFF;
    sp-10.unk10 = arg0;
    sp-10.unk14 = arg1;
    temp_v1 = (temp_t6 * 0x24C) + &D_801930D0;
    temp_a2 = temp_v1->unk41;
    phi_v0 = 0;
    phi_a2 = temp_a2;
    if (temp_a2 > 0) {
        do {
            temp_a3 = (temp_t6 * 0x24C) + &D_801930D0 + (phi_v0 * 4);
            temp_t9 = (phi_v0 + 1) & 0xFF;
            if ((arg1 & 0xFF) == (((temp_a3->unk2C & 0xF00000) >> 0x14) & 0xFF)) {
                temp_a3->unk2C = 0xFF000000;
                phi_a2 = temp_v1->unk41;
            }
            phi_v0 = temp_t9;
        } while (temp_t9 < phi_a2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C3608.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_801930D0;

void func_800C36C4(s32 arg0, s32 arg1, u8 arg2, s8 arg3) {
    void *temp_v0;

    temp_v0 = ((arg0 & 0xFF) * 0x24C) + &D_801930D0;
    (temp_v0 + (arg1 & 0xFF))->unkE = arg2;
    temp_v0->unk11 = arg3;
    temp_v0->unk12 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C36C4.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C3448(s32, s8, s32);                      /* extern */
? func_800C36C4(s32, ?, ?, ?);                      /* extern */
? func_800CBB88(s32, f32, s32);                     /* extern */
? func_800CBBB8(s32, s32);                          /* extern */
extern ? D_801930D0;

void func_800C3724(void) {
    f32 temp_f2;
    f32 var_f0;
    f32 var_f0_2;
    f32 var_f16;
    f32 var_f6;
    f32 var_f8;
    s16 temp_t7_2;
    s16 var_t0;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_a1;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_a3;
    s32 temp_a3_2;
    s32 temp_at;
    s32 temp_lo;
    s32 temp_s1;
    s32 temp_t2_3;
    s32 temp_t3;
    s32 temp_t4_2;
    s32 temp_t5_2;
    s32 temp_t7;
    s32 temp_t7_3;
    s32 temp_t9_2;
    s32 temp_v0_7;
    s32 temp_v1;
    s32 var_a2;
    s32 var_s0;
    s32 var_s0_2;
    s32 var_s2;
    s32 var_s2_2;
    s32 var_s5;
    s8 temp_a1_3;
    struct SequencePlayer *temp_a1_2;
    u16 temp_t2_2;
    u16 temp_t4;
    u16 temp_t5;
    u16 temp_v0;
    u16 temp_v0_2;
    u16 temp_v0_3;
    u16 temp_v1_2;
    u16 temp_v1_4;
    u32 temp_t5_3;
    u32 temp_t9;
    u8 temp_t2;
    u8 temp_v0_6;
    u8 temp_v1_6;
    void *temp_s0;
    void *temp_s0_2;
    void *temp_s0_3;
    void *temp_s3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v1_3;
    void *temp_v1_5;

    var_s5 = 0;
    do {
        temp_s3 = &D_801930D0 + (var_s5 * 0x24C);
        if (temp_s3->unk12 != 0) {
            var_f0 = 1.0f;
            var_s2 = 0;
            do {
                temp_t2 = (&D_801930D0 + (var_s5 * 0x24C) + var_s2)->unkE;
                var_f6 = (f32) temp_t2;
                if ((s32) temp_t2 < 0) {
                    var_f6 += 4294967296.0f;
                }
                temp_t3 = (var_s2 + 1) & 0xFF;
                temp_at = temp_t3 < 3;
                var_s2 = temp_t3;
                var_f0 *= var_f6 / 127.0f;
            } while (temp_at != 0);
            func_800C3448((temp_s3->unk11 << 0x10) | 0x40000000 | (var_s5 << 0x18) | ((u32) (var_f0 * 127.0f) & 0xFF));
            temp_s3->unk12 = 0U;
        }
        temp_v0 = temp_s3->unkC;
        temp_t4 = temp_v0 - 1;
        if (temp_v0 != 0) {
            temp_s3->unkC = temp_t4;
            if (temp_t4 & 0xFFFF) {
                temp_s3->unk0 = (f32) (temp_s3->unk0 - temp_s3->unk8);
            } else {
                temp_s3->unk0 = (f32) temp_s3->unk4;
            }
            func_800CBB88(((var_s5 & 0xFF) << 0x10) | 0x41000000, temp_s3->unk0);
        }
        temp_a1 = temp_s3->unk14;
        if (temp_a1 != 0) {
            temp_t9 = (u32) (temp_a1 & 0xFF0000) >> 0xF;
            temp_a0 = temp_a1 & 0xFFF;
            temp_a3 = temp_t9 & 0xFF;
            var_t0 = temp_t9 & 0xFF;
            var_a2 = temp_a0 & 0xFFFF;
            if (temp_a3 == 0) {
                var_t0 = (temp_a3 + 1) & 0xFF;
            }
            temp_a1_2 = &gSequencePlayers[var_s5];
            if (((u32) temp_a1_2->unk0 >> 0x1F) != 0) {
                temp_t9_2 = ((u32) (temp_a1 & 0xF000) >> 0xC) & 0xFF;
                temp_lo = (s32) temp_a1_2->tempo / 48;
                temp_a3_2 = temp_lo & 0xFFFF;
                if (temp_t9_2 != 1) {
                    temp_v1 = temp_a0 & 0xFFFF;
                    switch (temp_t9_2) {            /* switch 1; irregular */
                    case 2:                         /* switch 1 */
                        if (temp_v1 < temp_a3_2) {
                            var_a2 = (temp_a3_2 - temp_v1) & 0xFFFF;
                        }
                        break;
                    case 3:                         /* switch 1 */
                        var_f16 = (f32) temp_a3_2;
                        if (temp_a3_2 < 0) {
                            var_f16 += 4294967296.0f;
                        }
                        var_a2 = (u32) (var_f16 * ((f32) (temp_a0 & 0xFFFF) / 100.0f)) & 0xFFFF;
                        break;
                    case 4:                         /* switch 1 */
                        temp_v0_2 = temp_s3->unk18;
                        var_a2 = temp_a3_2 & 0xFFFF;
                        if (temp_v0_2 != 0) {
                            var_a2 = temp_v0_2 & 0xFFFF;
                        }
                        break;
                    }
                } else {
                    var_a2 = (temp_a0 + temp_a3_2) & 0xFFFF;
                }
                temp_f2 = (f32) temp_lo;
                if (var_a2 >= 0x12D) {
                    var_a2 = 0x12C;
                }
                if (temp_s3->unk18 == 0) {
                    temp_s3->unk18 = (u16) temp_a3_2;
                }
                var_f0_2 = (f32) var_a2;
                if (var_a2 < 0) {
                    var_f0_2 += 4294967296.0f;
                }
                temp_s3->unk20 = var_f0_2;
                temp_s3->unk1C = temp_f2;
                var_f8 = (f32) var_t0;
                if (var_t0 < 0) {
                    var_f8 += 4294967296.0f;
                }
                temp_s3->unk28 = var_t0;
                temp_s3->unk24 = (f32) ((temp_f2 - var_f0_2) / var_f8);
            }
            temp_s3->unk14 = 0;
        }
        temp_v0_3 = (u16) temp_s3->unk28;
        temp_t7_2 = temp_v0_3 - 1;
        if (temp_v0_3 != 0) {
            temp_s3->unk28 = temp_t7_2;
            if (temp_t7_2 & 0xFFFF) {
                temp_s3->unk1C = (f32) (temp_s3->unk1C - temp_s3->unk24);
            } else {
                temp_s3->unk1C = (f32) temp_s3->unk20;
            }
            func_800CBBB8(((var_s5 & 0xFF) << 0x10) | 0x47000000, (s32) temp_s3->unk1C);
        }
        if (temp_s3->unk246 != 0) {
            var_s0 = 0;
            do {
                temp_a0_2 = var_s0 << 5;
                temp_v0_4 = &D_801930D0 + (var_s5 * 0x24C) + temp_a0_2;
                temp_v1_2 = temp_v0_4->unk50;
                temp_t5 = temp_v1_2 - 1;
                if (temp_v1_2 != 0) {
                    temp_v0_4->unk50 = temp_t5;
                    temp_a2 = ((var_s5 & 0xFF) << 0x10) | 0x01000000;
                    if (temp_t5 & 0xFFFF) {
                        temp_v0_4->unk44 = (f32) (temp_v0_4->unk44 - temp_v0_4->unk4C);
                    } else {
                        temp_v1_3 = temp_s3 + temp_a0_2;
                        temp_v1_3->unk44 = (f32) temp_v1_3->unk48;
                        temp_s3->unk246 = (u16) (temp_s3->unk246 ^ (1 << var_s0));
                    }
                    func_800CBB88(temp_a2 | ((var_s0 & 0xFF) << 8), temp_v0_4->unk44, temp_a2);
                }
                temp_t7_3 = (var_s0 + 1) & 0xFF;
                var_s0 = temp_t7_3;
            } while (temp_t7_3 < 0x10);
        }
        if (temp_s3->unk244 != 0) {
            var_s0_2 = 0;
            do {
                temp_a0_3 = var_s0_2 << 5;
                temp_v0_5 = &D_801930D0 + (var_s5 * 0x24C) + temp_a0_3;
                temp_v1_4 = temp_v0_5->unk60;
                temp_t2_2 = temp_v1_4 - 1;
                if (temp_v1_4 != 0) {
                    temp_v0_5->unk60 = temp_t2_2;
                    temp_a2_2 = ((var_s5 & 0xFF) << 0x10) | 0x04000000;
                    if (temp_t2_2 & 0xFFFF) {
                        temp_v0_5->unk54 = (f32) (temp_v0_5->unk54 - temp_v0_5->unk5C);
                    } else {
                        temp_v1_5 = temp_s3 + temp_a0_3;
                        temp_v1_5->unk54 = (f32) temp_v1_5->unk58;
                        temp_s3->unk244 = (u16) (temp_s3->unk244 ^ (1 << var_s0_2));
                    }
                    func_800CBB88(temp_a2_2 | ((var_s0_2 & 0xFF) << 8), temp_v0_5->unk54, temp_a2_2);
                }
                temp_t4_2 = (var_s0_2 + 1) & 0xFF;
                var_s0_2 = temp_t4_2;
            } while (temp_t4_2 < 0x10);
        }
        temp_v0_6 = temp_s3->unk41;
        if (temp_v0_6 != 0) {
            temp_v1_6 = temp_s3->unk40;
            if (temp_v1_6 != 0) {
                temp_s3->unk40 = (u8) (temp_v1_6 - 1);
            } else {
                var_s2_2 = 0;
                if (((u32) gSequencePlayers[var_s5].unk0 >> 0x1F) == 0) {
                    if ((s32) temp_v0_6 > 0) {
                        do {
                            temp_v0_7 = (&D_801930D0 + (var_s5 * 0x24C) + (var_s2_2 * 4))->unk2C;
                            temp_t5_3 = ((u32) (temp_v0_7 & 0xF00000) >> 0x14) & 0xFF;
                            temp_t2_3 = temp_v0_7 & 0xFF;
                            temp_s1 = ((u32) (temp_v0_7 & 0xF0000) >> 0x10) & 0xFF;
                            temp_a1_3 = ((u32) (temp_v0_7 & 0xFF00) >> 8) & 0xFF;
                            switch (temp_t5_3) {
                            case 0:
                                temp_s0 = &D_801930D0 + (temp_s1 * 0x24C);
                                temp_s0->unk12 = 1;
                                temp_s0->unkF = 0x7F;
                                break;
                            case 1:
                                func_800C3448(temp_s3->unk248 | 0x30000000 | (var_s5 << 0x18), temp_a1_3, temp_t2_3);
                                break;
                            case 2:
                                temp_s0_2 = &D_801930D0 + (temp_s1 * 0x24C);
                                func_800C3448(temp_s0_2->unk248 | (temp_s1 << 0x18) | 0x10000, temp_a1_3, temp_t2_3);
                                temp_s0_2->unk12 = 1;
                                temp_s0_2->unkF = 0x7F;
                                break;
                            case 3:
                                func_800C3448((temp_s1 << 0x18) | 0xB0003000 | (temp_a1_3 << 0x10) | temp_t2_3, temp_a1_3, temp_t2_3);
                                break;
                            case 4:
                                func_800C3448((temp_s1 << 0x18) | 0xB0004000 | (temp_t2_3 << 0x10), temp_a1_3, temp_t2_3);
                                break;
                            case 5:
                                temp_s0_3 = &D_801930D0 + (temp_s1 * 0x24C);
                                func_800C3448((temp_s0_3->unk42 << 0x10) | (temp_s1 << 0x18) | (temp_v0_7 & 0xFFFF), temp_a1_3, temp_t2_3);
                                func_800C36C4(temp_s1 & 0xFF, 1, 0x7F, 0);
                                temp_s0_3->unk42 = 0U;
                                break;
                            case 6:
                                temp_s3->unk42 = temp_a1_3;
                                break;
                            }
                            temp_t5_2 = (var_s2_2 + 1) & 0xFF;
                            var_s2_2 = temp_t5_2;
                        } while (temp_t5_2 < (s32) temp_s3->unk41);
                    }
                    temp_s3->unk41 = 0U;
                }
            }
        }
        temp_t7 = (var_s5 + 1) & 0xFF;
        var_s5 = temp_t7;
    } while (temp_t7 < 3);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C3724.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80192CC6;
extern ? D_801930D0;

void func_800C3F70(void) {
    ? sp-10;
    s32 temp_t8;
    void *temp_v1;
    s32 phi_v0;

    phi_v0 = 0;
    do {
        *(&D_80192CC6 + phi_v0) = 0;
        temp_t8 = (phi_v0 + 1) & 0xFF;
        temp_v1 = &D_801930D0 + (phi_v0 * 0x24C);
        temp_v1->unk248 = 0xFFFF;
        temp_v1->unk0 = 1.0f;
        temp_v1->unkC = 0;
        temp_v1->unk28 = 0;
        temp_v1->unk18 = 0;
        temp_v1->unk14 = 0;
        temp_v1->unk24A = 0;
        temp_v1->unk41 = 0;
        temp_v1->unk42 = 0;
        temp_v1->unk12 = 0;
        temp_v1->unkE = 0x7F;
        temp_v1->unkF = 0x7F;
        temp_v1->unk10 = 0x7F;
        temp_v1->unk244 = 0;
        temp_v1->unk246 = 0;
        phi_v0 = temp_t8;
    } while (temp_t8 < 3);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C3F70.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80192CC6;
extern ? D_801930D0;

void func_800C400C(void) {
    ? sp-10;
    s32 temp_t8;
    void *temp_v1;
    s32 phi_v0;

    phi_v0 = 0;
    do {
        *(&D_80192CC6 + phi_v0) = 0;
        temp_t8 = (phi_v0 + 1) & 0xFF;
        temp_v1 = &D_801930D0 + (phi_v0 * 0x24C);
        temp_v1->unk248 = 0xFFFF;
        temp_v1->unk28 = 0;
        temp_v1->unk18 = 0;
        temp_v1->unk14 = 0;
        temp_v1->unk24A = 0;
        temp_v1->unk41 = 0;
        temp_v1->unk42 = 0;
        temp_v1->unk244 = 0;
        temp_v1->unk246 = 0;
        phi_v0 = temp_t8;
    } while (temp_t8 < 3);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C400C.s")
#endif

// Appears to be an unused combo of sound_banks_enable and sound_banks_disable
void func_800C4084(u16 bankMask) {
    u8 bank;

    for (bank = 0; bank < SOUND_BANK_COUNT; bank++) {
        if (bankMask & 1) {
            sSoundBankDisabled[bank] = TRUE;
        } else {
            sSoundBankDisabled[bank] = FALSE;
        }
        bankMask = bankMask >> 1;
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern u16 D_800EA1C4;
extern ? D_801930D0;

void func_800C40F0(s32 arg0) {
    ? sp-10;
    u16 temp_t1;

    sp-10.unk10 = arg0;
    temp_t1 = D_800EA1C4 & ((1 << (arg0 & 0xFF)) ^ 0xFFFF);
    D_800EA1C4 = temp_t1;
    if ((temp_t1 & 0xFFFF) == 0) {
        D_801930D0.unk12 = 1;
        D_801930D0.unk10 = 0x7F;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C40F0.s")
#endif

void play_sound(u32 soundBits, f32 *position, u8 arg2, f32 *arg3, f32 *arg4, u8 *arg5) {
    u8 bank;
    struct Unk_8018FC20 *temp_v0;

    bank = soundBits >> 0x1C;
    if (sSoundBankDisabled[bank] == FALSE) {
        temp_v0 = &sSoundRequests[sSoundRequestCount];
        temp_v0->soundBits = soundBits;
        temp_v0->position = position;
        temp_v0->cameraId = arg2;
        temp_v0->unk0C = arg3;
        temp_v0->unk10 = arg4;
        temp_v0->unk14 = arg5;
        sSoundRequestCount += 1;
    }
}

#ifdef NEEDS_RODATA
// data/rodata_audio_2.s
extern f32 D_800F3648;// = 100000.0f;
// jpt_800F364C
// data_0DD0A0_2_1_1.s
// Plain data
extern Vec3f D_800EA1C8;// = { 0.0f, 0.0f, 0.0f, };

void func_800C41CC(u8 arg0, struct Unk_80191420 *arg1) {
    s32 found;
    u8 soundId;
    struct Unk_8018FC20 *sound;

    for (soundId = sNumProcessedSoundRequests; soundId != sSoundRequestCount; soundId++) {
        found = FALSE;
        sound = &sSoundRequests[soundId];
        switch (arg0) {
        case 0:
            if ((sound->soundBits & 0xF0000000) == (arg1->soundBits & 0xF0000000)) {
                found = TRUE;
            }
            break;
        case 1:
            if (((sound->soundBits & 0xF0000000) == (arg1->soundBits & 0xF0000000)) && (sound->position == arg1->unk00)) {
                found = TRUE;
            }
            break;
        case 2:
            if (sound->position == arg1->unk00) {
                found = TRUE;
            }
            break;
        case 3:
            if ((sound->position == arg1->unk00) && (sound->soundBits == arg1->soundBits)) {
                found = TRUE;
            }
            break;
        case 4:
            if ((sound->cameraId == arg1->cameraId) && (sound->soundBits == arg1->soundBits)) {
                found = TRUE;
            }
            break;
        case 5:
            if (sound->soundBits == arg1->soundBits) {
                found = TRUE;
            }
            break;
        }
        if (found) {
            sound->soundBits = 0;
            if (sound->position != D_800EA1C8) {
                sound->position[1] = 100000.0f;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C41CC.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C40F0(u8, s32, struct Unk_8018FC20 *, u8); /* extern */
static ? D_800EA1A0;                                /* unable to generate initializer; const */
static u8 D_800EA1C0 = 0;                           /* const */
static ? D_800EA1C8;                                /* unable to generate initializer; const */
u8 sNumProcessedSoundRequests = 0;                  /* const */

void func_800C4398(void) {
    u8 sp4F;
    u8 sp4D;
    struct Unk_8018FC20 *sp48;
    u8 sp43;
    u32 sp3C;
    struct Unk_80191420 *sp30;
    f32 *temp_v0_3;
    s32 temp_a1;
    s32 temp_a1_2;
    struct Unk_8018FC20 *var_a2;
    struct Unk_80191420 *temp_s0;
    struct Unk_80191420 *temp_s0_2;
    struct Unk_80191420 *temp_s0_3;
    struct Unk_80191420 *temp_t0;
    struct Unk_80191420 *temp_t1;
    struct Unk_80191420 *var_t1;
    u32 temp_v0;
    u32 var_t3;
    u8 *temp_a3;
    u8 *temp_v0_2;
    u8 temp_a0;
    u8 temp_a0_2;
    u8 temp_a1_3;
    u8 temp_t6;
    u8 temp_t6_2;
    u8 temp_v1;
    u8 var_a3;
    u8 var_t2;
    u8 var_t5;
    u8 var_v0;
    u8 var_v0_2;
    u8 var_v1;

    var_a2 = &sSoundRequests[sNumProcessedSoundRequests];
    temp_a1 = var_a2->soundBits;
    if (temp_a1 != 0) {
        temp_t6 = ((u32) (temp_a1 & 0xF0000000) >> 0x1C) & 0xFF;
        var_v1 = sSoundBanks[temp_t6]->next;
        var_t5 = temp_t6;
        var_a3 = 0;
        var_v0 = var_v1;
        if ((var_v1 != 0xFF) && (var_v1 != 0)) {
            var_t1 = sSoundBanks[temp_t6];
            var_t3 = sp3C;
            var_t2 = sp43;
loop_4:
            temp_s0 = &var_t1[var_v1];
            if (var_a2->position == temp_s0->unk00) {
                temp_a1_2 = var_a2->soundBits;
                temp_v0 = temp_s0->soundBits;
                temp_a0 = *(&D_800EA1A0 + ((D_800EA1C0 * 6) + var_t5));
                if (temp_a1_2 == temp_v0) {
                    var_a3 = temp_a0 & 0xFF;
                    var_v0_2 = var_a3;
                } else {
                    if (var_a3 == 0) {
                        var_t2 = var_v1 & 0xFF;
                        goto block_11;
                    }
                    if ((u32) (temp_v0 & 0xFF00) < (u32) (var_t3 & 0xFF00)) {
                        var_t2 = var_v1 & 0xFF;
block_11:
                        var_t3 = temp_v0;
                    }
                    var_v0_2 = (var_a3 + 1) & 0xFF;
                    var_a3 = var_v0_2;
                    if (var_v0_2 == temp_a0) {
                        var_v1 = 0;
                        if ((u32) (temp_a1_2 & 0xFF00) >= (u32) (var_t3 & 0xFF00)) {
                            var_v1 = var_t2 & 0xFF;
                        }
                    }
                }
                if (var_v0_2 == temp_a0) {
                    if ((temp_a1_2 & 0x08000000) || (temp_a1_2 & 0x40000) || (var_t2 == var_v1)) {
                        temp_s0_2 = &var_t1[var_v1];
                        if ((temp_s0_2->soundBits & 0x80000) && (temp_s0_2->soundStatus != 1)) {
                            sp4F = var_t5;
                            sp3C = var_t3;
                            sp43 = var_t2;
                            sp30 = var_t1;
                            sp4D = var_a3;
                            sp48 = var_a2;
                            func_800C40F0(temp_s0_2->unk2C, temp_a1_2, var_a2, var_a3);
                        }
                        temp_s0_2->unk0C = var_a2->cameraId;
                        temp_s0_2->soundBits = (u32) var_a2->soundBits;
                        temp_s0_2->freshness = 2;
                        temp_s0_2->soundStatus = (u8) ((u32) (var_a2->soundBits & 0x01000000) >> 0x18);
                        temp_s0_2->unk10 = var_a2->unk0C;
                        temp_s0_2->unk14 = var_a2->unk10;
                        temp_s0_2->unk18 = var_a2->unk14;
                    }
                    var_v1 = 0;
                }
            }
            var_v0 = var_v1;
            if (var_v1 != 0) {
                var_v1 = var_t1[var_v1].next;
                var_v0 = var_v1;
            }
            if (var_v0 != 0xFF) {
                if (var_v0 == 0) {
                    sp3C = var_t3;
                    sp43 = var_t2;
                } else {
                    goto loop_4;
                }
            }
        }
        temp_a3 = &sSoundBankFreeListFront[var_t5];
        temp_a1_3 = *temp_a3;
        temp_t1 = sSoundBanks[var_t5];
        temp_t0 = &temp_t1[temp_a1_3];
        temp_v1 = temp_t0->next;
        if ((temp_v1 != 0xFF) && (var_v0 != 0)) {
            temp_s0_3 = &temp_t1[temp_a1_3 & 0xFF];
            temp_s0_3->unk00 = var_a2->position;
            temp_s0_3->unk04 = var_a2->position + 4;
            temp_s0_3->unk08 = var_a2->position + 8;
            temp_s0_3->unk0C = var_a2->cameraId;
            temp_s0_3->unk10 = var_a2->unk0C;
            temp_s0_3->unk14 = var_a2->unk10;
            temp_s0_3->unk18 = var_a2->unk14;
            temp_s0_3->soundBits = (u32) var_a2->soundBits;
            temp_s0_3->freshness = 2;
            temp_v0_2 = &sSoundBankUsedListBack[var_t5];
            temp_a0_2 = *temp_v0_2;
            temp_s0_3->soundStatus = (u8) ((u32) (var_a2->soundBits & 0x01000000) >> 0x18);
            temp_s0_3->prev = temp_a0_2;
            temp_t1[temp_a0_2].next = temp_a1_3;
            temp_t6_2 = temp_t0->next;
            *temp_v0_2 = temp_a1_3;
            *temp_a3 = temp_t6_2;
            temp_t1[temp_t6_2 & 0xFF].prev = 0xFF;
            temp_s0_3->next = 0xFF;
            return;
        }
        if (temp_v1 == 0xFF) {
            temp_v0_3 = var_a2->position;
            if (&D_800EA1C8 != temp_v0_3) {
                temp_v0_3->unk4 = 100000.0f;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C4398.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C40F0(u8, u8, struct Unk_80191420 *, u8); /* extern */
static ? D_800EA1C8;                                /* unable to generate initializer; const */

// delete_sound_from_bank? Very similar, but has some extra stuff
void func_800C473C(u8 bankId, u8 soundId) {
    struct Unk_80191420 *sp34;
    struct Unk_80191420 *sp30;
    struct Unk_80191420 *temp_a2;
    struct Unk_80191420 *temp_v0;
    u8 *temp_v1;
    u8 *temp_v1_2;
    u8 temp_t6;
    u8 var_a1;
    u8 var_a3;

    temp_t6 = soundId & 0xFF;
    var_a3 = bankId & 0xFF;
    temp_a2 = sSoundBanks[var_a3];
    temp_v0 = &temp_a2[temp_t6];
    var_a1 = temp_t6;
    if (&D_800EA1C8 != temp_v0->unk00) {
        *temp_v0->unk04 = 100000.0f;
    }
    if (temp_v0->soundBits & 0x80000) {
        bankId = var_a3;
        sp34 = temp_a2;
        soundId = var_a1;
        sp30 = temp_v0;
        func_800C40F0(temp_v0->unk2C, var_a1, temp_a2, var_a3);
        var_a1 = soundId;
        var_a3 = bankId;
    }
    temp_v1 = &sSoundBankUsedListBack[var_a3];
    if (var_a1 == *temp_v1) {
        *temp_v1 = temp_v0->prev;
    } else {
        temp_a2[temp_v0->next].prev = temp_v0->prev;
    }
    temp_v1_2 = &sSoundBankFreeListFront[var_a3];
    temp_a2[temp_v0->prev].next = temp_v0->next;
    temp_v0->prev = 0xFF;
    temp_v0->next = *temp_v1_2;
    temp_a2[*temp_v1_2].prev = var_a1;
    *temp_v1_2 = var_a1;
    temp_v0->soundStatus = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C473C.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C473C(s32, u8, void *, u8);               /* extern */
? func_800CBBE8(s32, ?);                            /* extern */
extern ? D_80192AB8;
static ? D_800EA188;                                /* unable to generate initializer; const */
static u8 D_800EA1C0 = 0;                           /* const */
static ? D_800EA1C8;                                /* unable to generate initializer; const */

void func_800C4888(s32 arg0) {
    u8 spCE;
    u8 spCC;
    ? sp7C;
    void *sp70;
    struct Unk_80191420 *sp6C;
    struct Unk_80191420 *sp68;
    s32 sp60;
    f32 *temp_v0;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f2;
    f32 var_f0;
    s32 temp_a2;
    s32 temp_at;
    s32 temp_s5;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_t7;
    s32 temp_t7_2;
    s32 temp_t7_3;
    s32 temp_t8;
    s32 temp_t8_3;
    s32 temp_t8_4;
    s32 temp_t9;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 var_a1;
    s32 var_a1_2;
    s32 var_a1_3;
    s32 var_s0;
    s32 var_s0_2;
    s32 var_s2;
    s32 var_t3;
    s32 var_t3_2;
    s32 var_t3_3;
    s32 var_v1;
    struct Unk_80191420 *temp_a0_2;
    struct Unk_80191420 *temp_t2;
    struct Unk_80191420 *temp_v0_7;
    u32 temp_t8_2;
    u32 temp_v0_2;
    u8 temp_a1;
    u8 temp_a3_3;
    u8 temp_a3_4;
    u8 temp_t4;
    u8 temp_v1;
    u8 var_s3;
    u8 var_t0;
    u8 var_t1;
    u8 var_t2;
    u8 var_v1_2;
    void *temp_a0;
    void *temp_a0_3;
    void *temp_a0_4;
    void *temp_a3;
    void *temp_a3_2;
    void *temp_s3;
    void *temp_v0_6;
    void *var_a2;

    temp_s5 = arg0 & 0xFF;
    var_s2 = 0;
    var_t3 = 0;
    do {
        temp_t7 = (var_t3 + 1) & 0xFF;
        temp_at = temp_t7 < 8;
        temp_a3 = &sp7C + (var_t3 * 8);
        var_t3 = temp_t7;
        temp_a3->unk0 = 0x7FFFFFFF;
        temp_a3->unk4 = 0xFFU;
    } while (temp_at != 0);
    var_s3 = sSoundBanks[temp_s5]->next;
    var_s0 = 0;
    if (var_s3 != 0xFF) {
        sp6C = sSoundBanks[temp_s5];
        do {
            temp_t2 = &sp6C[var_s3];
            if ((temp_t2->soundStatus == 1) && ((temp_t2->soundBits & 0x08000000) == 0x08000000)) {
                temp_t2->freshness -= 1;
            }
            if (temp_t2->freshness == 0) {
                func_800C473C(temp_s5 & 0xFF, var_s3 & 0xFF);
            } else if (temp_t2->soundStatus != 0) {
                temp_v0 = temp_t2->unk00;
                if (&D_800EA1C8 == temp_v0) {
                    temp_t2->distance = 0.0f;
                } else {
                    temp_f2 = *temp_v0;
                    temp_f0 = *temp_t2->unk08;
                    temp_t2->distance = (temp_f0 * temp_f0) + (temp_f2 * temp_f2);
                }
                temp_v0_2 = temp_t2->soundBits;
                temp_t8 = ((u32) (temp_v0_2 & 0xFF00) >> 8) & 0xFF;
                if (temp_v0_2 & 0x100000) {
                    temp_v0_3 = 0xFFU - temp_t8;
                    temp_t2->priority = temp_v0_3 * temp_v0_3 * 0x5A4;
                } else {
                    temp_v0_4 = 0xFFU - temp_t8;
                    temp_t8_2 = (u32) temp_t2->distance + (temp_v0_4 * temp_v0_4 * 0x5A4);
                    temp_t2->priority = temp_t8_2;
                    temp_f0_2 = *temp_t2->unk08;
                    if (temp_f0_2 > 0.0f) {
                        temp_t2->priority = temp_t8_2 + (s32) (temp_f0_2 * 6.0f);
                    }
                }
                temp_t8_3 = ((u32) (temp_t2->soundBits & 0x30000) >> 0x10) & 0xFF;
                if (temp_t8_3 != 0) {
                    var_f0 = 4000000.0f / (f32) (temp_t8_3 * temp_t8_3);
                } else {
                    var_f0 = 1e10f;
                }
                if (var_f0 < temp_t2->distance) {
                    if (temp_t2->soundStatus == 4) {
                        sp68 = temp_t2;
                        func_800CBBE8((temp_t2->unk2C << 8) | 0x06020000, 0);
                        if (temp_t2->soundBits & 0x08000000) {
                            func_800C473C(temp_s5 & 0xFF, var_s3 & 0xFF);
                            var_s3 = var_s0 & 0xFF;
                        }
                    }
                } else {
                    var_t3_2 = 0;
                    temp_t4 = *(&D_800EA188 + ((D_800EA1C0 * 6) + temp_s5));
                    if ((s32) temp_t4 > 0) {
                        do {
                            temp_a3_2 = &sp7C + (var_t3_2 * 8);
                            temp_v0_5 = temp_t4 - 1;
                            var_a1 = temp_v0_5 & 0xFF;
                            temp_a2 = var_t3_2;
                            if ((u32) temp_a3_2->unk0 >= (u32) temp_t2->priority) {
                                if (var_s2 < (s32) temp_t4) {
                                    var_s2 = (var_s2 + 1) & 0xFF;
                                }
                                var_t3_2 = temp_t4 & 0xFF;
                                if (temp_a2 < (temp_v0_5 & 0xFF)) {
                                    var_v1 = var_a1;
                                    do {
                                        temp_v0_6 = &sp7C + (var_v1 * 8);
                                        temp_a0 = &sp7C + (var_a1 * 8);
                                        temp_a0->unk0 = (s32) temp_v0_6->unk-8;
                                        var_v1 = (var_a1 - 1) & 0xFF;
                                        var_a1 = var_v1;
                                        temp_a0->unk4 = (u8) temp_v0_6->unk-4;
                                    } while (temp_a2 < var_v1);
                                }
                                temp_a3_2->unk0 = temp_t2->priority;
                                temp_a3_2->unk4 = var_s3;
                            }
                            temp_t9 = (var_t3_2 + 1) & 0xFF;
                            var_t3_2 = temp_t9;
                        } while (temp_t9 < (s32) temp_t4);
                    }
                }
                var_s0 = var_s3 & 0xFF;
            }
            var_s3 = sp6C[var_s0].next;
        } while (var_s3 != 0xFF);
    }
    var_t1 = *(&D_800EA188 + ((D_800EA1C0 * 6) + temp_s5));
    var_t3_3 = 0;
    if (var_s2 > 0) {
        sp6C = sSoundBanks[temp_s5];
        do {
            temp_t7_2 = (var_t3_3 + 1) & 0xFF;
            temp_v0_7 = &sp6C[(&sp7C + (var_t3_3 * 8))->unk4];
            temp_v1 = temp_v0_7->soundStatus;
            if (temp_v1 == 1) {
                temp_v0_7->soundStatus = 2;
            } else if (temp_v1 == 4) {
                temp_v0_7->soundStatus = 3;
            }
            var_t3_3 = temp_t7_2;
        } while (temp_t7_2 < var_s2);
        var_t3_3 = 0;
    }
    var_t0 = var_t1;
    if ((s32) var_t1 > 0) {
        var_a2 = (temp_s5 << 6) + &D_80192AB8;
        do {
            temp_s3 = var_a2 + (var_t3_3 * 8);
            temp_a1 = temp_s3->unk4;
            var_v1_2 = 0;
            if (temp_a1 == 0xFF) {
                var_v1_2 = 1;
            } else {
                temp_a0_2 = &sSoundBanks[temp_s5][temp_a1];
                temp_a3_3 = temp_a0_2->soundStatus;
                if (temp_a3_3 == 4) {
                    if (temp_a0_2->soundBits & 0x08000000) {
                        sp70 = var_a2;
                        sp60 = (s32) var_t0;
                        spCE = var_t1;
                        spCC = (u8) var_t3_3;
                        func_800C473C(temp_s5 & 0xFF, temp_a1, var_a2, temp_a3_3);
                        var_v1_2 = 1;
                    } else {
                        temp_a0_2->soundStatus = 1;
                        var_v1_2 = 1;
                    }
                } else if (temp_a3_3 == 0) {
                    temp_s3->unk4 = 0xFFU;
                    var_v1_2 = 1;
                } else {
                    var_a1_2 = 0;
                    if ((s32) var_t0 > 0) {
                        do {
                            temp_a0_3 = &sp7C + (var_a1_2 * 8);
                            if (temp_a1 == temp_a0_3->unk4) {
                                temp_a0_3->unk4 = 0xFFU;
                                var_a1_2 = var_t1 & 0xFF;
                            }
                            temp_t7_3 = (var_a1_2 + 1) & 0xFF;
                            var_a1_2 = temp_t7_3;
                        } while (temp_t7_3 < (s32) var_t0);
                    }
                }
            }
            var_t2 = var_v1_2;
            if (var_v1_2 == 1) {
                var_a1_3 = 0;
                if ((s32) var_t0 > 0) {
                    do {
                        temp_a0_4 = &sp7C + (var_a1_3 * 8);
                        temp_a3_4 = temp_a0_4->unk4;
                        if ((temp_a3_4 != 0xFF) && (sSoundBanks[temp_s5][temp_a3_4].soundStatus != 3)) {
                            var_s0_2 = 0;
                            if ((s32) var_t0 > 0) {
                                do {
                                    if (temp_a3_4 == (var_a2 + (var_s0_2 * 8))->unk4) {
                                        var_v1_2 = 0;
                                        var_s0_2 = var_t1 & 0xFF;
                                    }
                                    temp_t6_2 = (var_s0_2 + 1) & 0xFF;
                                    var_s0_2 = temp_t6_2;
                                } while (temp_t6_2 < (s32) var_t0);
                                var_t2 = var_v1_2;
                            }
                            if (var_t2 == 1) {
                                temp_s3->unk4 = temp_a3_4;
                                temp_a0_4->unk4 = 0xFFU;
                                var_a1_3 = (var_t0 + 1) & 0xFF;
                            }
                        }
                        temp_t8_4 = (var_a1_3 + 1) & 0xFF;
                        var_a1_3 = temp_t8_4;
                    } while (temp_t8_4 < (s32) var_t0);
                }
                if (var_t0 == var_a1_3) {
                    temp_s3->unk4 = 0xFFU;
                }
            }
            temp_t6 = (var_t3_3 + 1) & 0xFF;
            var_t3_3 = temp_t6;
        } while (temp_t6 < (s32) var_t0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C4888.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C19D0(s32, s32, u8); // extern
void func_800C473C(s32, s32); // extern
void func_800CBBE8(s32, s8, u8); // extern
extern ? D_800EA188;
extern u8 D_800EA1C0;
extern u16 D_800EA1C4;
extern ? sSoundBanks;
extern ? D_80192AB8;
extern u8 D_80192C38;
extern ? D_801930D0;
extern s32 D_803B17D0;

void func_800C4FE4(s32 arg0) {
    void *sp50;
    s32 temp_s3;
    s32 temp_t7;
    u8 temp_a2;
    u8 temp_s1;
    u8 temp_v0;
    u8 temp_v1;
    void *temp_s0;
    s32 phi_s4;
    s32 phi_v1;
    u8 *phi_v1_2;

    temp_s3 = arg0 & 0xFF;
    temp_v1 = *(&D_800EA188 + ((D_800EA1C0 * 6) + temp_s3));
    phi_s4 = 0;
    phi_v1 = temp_v1;
    if (temp_v1 > 0) {
        sp50 = (temp_s3 << 6) + &D_80192AB8;
        do {
            temp_s1 = (sp50 + (phi_s4 * 8))->unk4;
            if (temp_s1 != 0xFF) {
                temp_a2 = D_80192C38;
                temp_s0 = (temp_s3 * 0x3C0) + (temp_s1 * 0x30) + &sSoundBanks;
                temp_v0 = temp_s0->unk28;
                if (temp_v0 == 2) {
                    temp_s0->unk2C = temp_a2;
                    if (temp_s0->unk24 & 0x80000) {
                        D_800EA1C4 = D_800EA1C4 | (1 << D_80192C38);
                        D_801930D0.unk12 = 1;
                        D_801930D0.unk10 = 0x28;
                    }
                    func_800C19D0(temp_s3 & 0xFF, temp_s1 & 0xFF, D_80192C38);
                    func_800CBBE8((D_80192C38 << 8) | 0x6020000, 1);
                    func_800CBBE8((D_80192C38 << 8) | 0x6020000 | 4, temp_s0->unk24);
                    temp_s0->unk28 = 4;
                    phi_v1_2 = &D_800EA188 + ((D_800EA1C0 * 6) + temp_s3);
                    goto block_11;
                }
                if ((*(&D_803B17D0 + (temp_a2 * 4)))->unk5F == 0x80) {
                    func_800CBBE8(((temp_a2 & 0xFF) << 8) | 0x6020000 | 7, 0, temp_a2);
                    func_800C473C(temp_s3 & 0xFF, temp_s1 & 0xFF);
                    phi_v1_2 = &D_800EA188 + ((D_800EA1C0 * 6) + temp_s3);
                    goto block_11;
                }
                if (temp_v0 == 3) {
                    func_800C19D0(temp_s3 & 0xFF, temp_s1 & 0xFF, temp_a2);
                    temp_s0->unk28 = 4;
                    phi_v1_2 = &D_800EA188 + ((D_800EA1C0 * 6) + temp_s3);
block_11:
                    phi_v1 = *phi_v1_2;
                }
            }
            temp_t7 = (phi_s4 + 1) & 0xFF;
            D_80192C38 = D_80192C38 + 1;
            phi_s4 = temp_t7;
        } while (temp_t7 < phi_v1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C4FE4.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C473C(s32, s32);                          /* extern */
? func_800CBBE8(s32, ?);                            /* extern */

void func_800C5278(u8 bank) {
    struct Unk_80191420 sp60;
    s32 temp_s7;
    struct Unk_80191420 *temp_s0;
    struct Unk_80191420 *temp_s2;

    temp_s7 = bank & 0xFF;
    temp_s2 = sSoundBanks[temp_s7];
    if (temp_s2->next != 0xFF) {
        do {
            temp_s0 = &sSoundBanks[temp_s7][temp_s2->next];
            if ((s32) temp_s0->soundStatus >= 3) {
                func_800CBBE8((temp_s0->unk2C << 8) | 0x06020000, 0);
            }
            if (temp_s0->soundStatus != 0) {
                func_800C473C(temp_s7 & 0xFF, temp_s2->next & 0xFF);
            }
        } while (temp_s2->next != 0xFF);
    }
    sp60.soundBits = temp_s7 << 0x1C;
    func_800C41CC(0U, &sp60);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C5278.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C473C(s32, s32);                          /* extern */
? func_800CBBE8(s32, ?);                            /* extern */

void func_800C5384(s32 arg0, s32 arg1) {
    s32 temp_s5;
    s32 var_s2;
    struct Unk_80191420 *temp_s0;
    struct Unk_80191420 *temp_s3;
    u8 var_s1;

    temp_s5 = arg0 & 0xFF;
    var_s1 = sSoundBanks[temp_s5]->next;
    var_s2 = 0;
    if (var_s1 != 0xFF) {
        temp_s3 = sSoundBanks[temp_s5];
        do {
            temp_s0 = &temp_s3[var_s1];
            if (arg1 == temp_s0->unk00) {
                if ((s32) temp_s0->soundStatus >= 3) {
                    func_800CBBE8((temp_s0->unk2C << 8) | 0x06020000, 0);
                }
                if (temp_s0->soundStatus != 0) {
                    func_800C473C(temp_s5 & 0xFF, var_s1 & 0xFF);
                }
                var_s1 = temp_s3[var_s2].next;
            } else {
                var_s2 = var_s1 & 0xFF;
                var_s1 = temp_s3[var_s2].next;
            }
        } while (var_s1 != 0xFF);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C5384.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C5384(u8);                                /* extern */

void func_800C54B8(u8 bank, struct Unk_80191420 *arg1) {
    s32 sp54;
    struct Unk_80191420 *sp30;

    func_800C5384(bank);
    sp54 = bank << 0x1C;
    sp30 = arg1;
    func_800C41CC(1U, (struct Unk_80191420 *) &sp30);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C54B8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C41CC(?, s32 *); // extern
void func_800C5384(s32, s32); // extern

void func_800C550C(s32 arg0) {
    s32 sp3C;
    s32 temp_t6;
    s32 phi_s0;

    phi_s0 = 0;
    do {
        func_800C5384(phi_s0 & 0xFF, arg0);
        temp_t6 = (phi_s0 + 1) & 0xFF;
        phi_s0 = temp_t6;
    } while (temp_t6 < 6);
    sp3C = arg0;
    func_800C41CC(2, &sp3C);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C550C.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C41CC(?, s32 *);                          /* extern */
? func_800C473C(s32, s32);                          /* extern */
? func_800CBBE8(s32, ?);                            /* extern */

void func_800C5578(s32 arg0, s32 arg1) {
    s32 sp84;
    s32 sp60;
    s32 temp_t8;
    s32 var_s3;
    struct Unk_80191420 *temp_s0;
    struct Unk_80191420 *temp_s4;
    u8 var_s1;
    u8 var_v0;

    temp_t8 = ((u32) (arg1 & 0xF0000000) >> 0x1C) & 0xFF;
    var_s1 = sSoundBanks[temp_t8]->next;
    var_s3 = 0;
    var_v0 = var_s1;
    if (var_s1 != 0xFF) {
        temp_s4 = sSoundBanks[temp_t8];
        do {
            temp_s0 = &temp_s4[var_s1];
            if ((arg0 == temp_s0->unk00) && (arg1 == temp_s0->soundBits)) {
                if ((s32) temp_s0->soundStatus >= 3) {
                    func_800CBBE8((temp_s0->unk2C << 8) | 0x06020000, 0);
                }
                if (temp_s0->soundStatus != 0) {
                    func_800C473C(temp_t8 & 0xFF, var_s1 & 0xFF);
                }
                var_s1 = 0xFF;
                var_v0 = 0xFF;
            } else {
                var_s3 = var_s1 & 0xFF;
            }
            if (var_v0 != 0xFF) {
                var_s1 = temp_s4[var_s3].next;
                var_v0 = var_s1;
            }
        } while (var_v0 != 0xFF);
    }
    sp60 = arg0;
    sp84 = arg1;
    func_800C41CC(3, &sp60);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C5578.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C41CC(?, ? *);                            /* extern */
? func_800C473C(s32, s32);                          /* extern */
? func_800CBBE8(s32, ?);                            /* extern */

void func_800C56F0(s32 arg0) {
    s32 sp8C;
    ? sp68;
    s32 temp_t8;
    s32 var_s2;
    struct Unk_80191420 *temp_s0;
    struct Unk_80191420 *temp_s3;
    u8 var_s1;

    temp_t8 = ((u32) (arg0 & 0xF0000000) >> 0x1C) & 0xFF;
    var_s1 = sSoundBanks[temp_t8]->next;
    var_s2 = 0;
    if (var_s1 != 0xFF) {
        temp_s3 = sSoundBanks[temp_t8];
        do {
            temp_s0 = &temp_s3[var_s1];
            if (arg0 == temp_s0->soundBits) {
                if ((s32) temp_s0->soundStatus >= 3) {
                    func_800CBBE8((temp_s0->unk2C << 8) | 0x06020000, 0);
                }
                if (temp_s0->soundStatus != 0) {
                    func_800C473C(temp_t8 & 0xFF, var_s1 & 0xFF);
                }
                var_s1 = temp_s3[var_s2].next;
            } else {
                var_s2 = var_s1 & 0xFF;
                var_s1 = temp_s3[var_s2].next;
            }
        } while (var_s1 != 0xFF);
    }
    sp8C = arg0;
    func_800C41CC(5, &sp68);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C56F0.s")
#endif

// Might be process_all_sound_requests
void func_800C5848(void) {
    while (sSoundRequestCount != sNumProcessedSoundRequests) {
        func_800C4398();
        sNumProcessedSoundRequests++;
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80192C48;

void func_800C58B8(s32 arg0, s32 arg1, s32 arg2) {
    ? sp-10;
    f32 temp_f0;
    f32 temp_f8;
    s16 temp_t8;
    void *temp_v0;
    s16 phi_a2;
    f32 phi_f8;

    sp-10.unk10 = arg0;
    sp-10.unk14 = arg1;
    sp-10.unk18 = arg2;
    temp_t8 = arg2 & 0xFFFF;
    phi_a2 = temp_t8;
    if (temp_t8 == 0) {
        phi_a2 = (temp_t8 + 1) & 0xFFFF;
    }
    temp_v0 = ((arg0 & 0xFF) * 0x10) + &D_80192C48;
    temp_f0 = (arg1 & 0xFF) / 127.0f;
    temp_v0->unkC = phi_a2;
    temp_f8 = phi_a2;
    temp_v0->unk4 = temp_f0;
    phi_f8 = temp_f8;
    if (phi_a2 < 0) {
        phi_f8 = temp_f8 + 4294967296.0f;
    }
    temp_v0->unk8 = (temp_v0->unk0 - temp_f0) / phi_f8;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C58B8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80192C48;

void func_800C5968(s32 arg0) {
    ? sp-10;
    u16 temp_t9;
    u16 temp_v1;
    void *temp_v0;

    sp-10.unk10 = arg0;
    temp_v0 = ((arg0 & 0xFF) * 0x10) + &D_80192C48;
    temp_v1 = temp_v0->unkC;
    temp_t9 = temp_v1 - 1;
    if (temp_v1 != 0) {
        temp_v0->unkC = temp_t9;
        if ((temp_t9 & 0xFFFF) != 0) {
            temp_v0->unk0 = temp_v0->unk0 - temp_v0->unk8;
            return;
        }
        temp_v0->unk0 = temp_v0->unk4;
        // Duplicate return node #4. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C5968.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C4888(s32); // extern
void func_800C4FE4(s32); // extern
void func_800C5968(s32); // extern
extern s8 D_80192C38;
extern s32 D_803B17D0;
extern ? gSequenceChannelNone;

void func_800C59C4(void) {
    s32 temp_t8;
    s32 phi_s0;

    if (&gSequenceChannelNone != D_803B17D0) {
        D_80192C38 = 0;
        phi_s0 = 0;
        do {
            func_800C4888(phi_s0 & 0xFF);
            func_800C4FE4(phi_s0 & 0xFF);
            func_800C5968(phi_s0 & 0xFF);
            temp_t8 = (phi_s0 + 1) & 0xFF;
            phi_s0 = temp_t8;
        } while (temp_t8 < 6);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C59C4.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
extern ? D_80192AB8;
extern ? D_80192C48;
static s16 D_800EA1C4 = 0;                          /* const */
u8 sNumProcessedSoundRequests = 0;                  /* const */
u8 sSoundRequestCount = 0;                          /* const */

// Looks EXTEREMELY similar to sound_init from SM64
// Its not quite the same but some very similar loops are found in each
void func_800C5A3C(void) {
    s32 temp_at;
    s32 temp_at_2;
    s32 temp_at_3;
    s32 temp_lo;
    s32 temp_t3;
    s32 temp_t4;
    s32 temp_t4_2;
    s32 temp_t4_3;
    s32 temp_t8;
    s32 var_a0;
    s32 var_v0;
    s32 var_v0_2;
    s32 var_v0_3;
    s32 var_v1;
    s32 var_v1_2;
    s8 temp_t3_2;
    s8 temp_t9_2;
    struct Unk_80191420 *temp_a1;
    struct Unk_80191420 *temp_a1_3;
    struct Unk_80191420 *temp_a2;
    void *temp_a1_2;
    void *temp_t9;
    void *temp_v1;

    sSoundRequestCount = 0;
    sNumProcessedSoundRequests = 0;
    D_800EA1C4 = 0;
    var_v0 = 0;
    do {
        sSoundBankUsedListBack[var_v0] = 0;
        sSoundBankFreeListFront[var_v0] = 1;
        temp_t4 = (var_v0 + 1) & 0xFF;
        sNumSoundsInBank[var_v0] = 0;
        temp_at = temp_t4 < 6;
        sSoundBankDisabled[var_v0] = 0;
        temp_v1 = &D_80192C48 + (var_v0 * 0x10);
        var_v0 = temp_t4;
        temp_v1->unk0 = 1.0f;
        temp_v1->unkC = 0;
    } while (temp_at != 0);
    var_v0_2 = 0;
    do {
        var_v1 = 0;
loop_4:
        temp_t3 = (var_v1 + 1) & 0xFF;
        temp_at_2 = temp_t3 < 8;
        temp_t9 = (var_v0_2 << 6) + &D_80192AB8 + (var_v1 * 8);
        var_v1 = temp_t3;
        temp_t9->unk4 = 0xFFU;
        if (temp_at_2 != 0) {
            goto loop_4;
        }
        temp_t4_2 = (var_v0_2 + 1) & 0xFF;
        var_v0_2 = temp_t4_2;
    } while (temp_t4_2 < 6);
    var_v0_3 = 0;
    do {
        temp_a2 = sSoundBanks[var_v0_3];
        var_v1_2 = 1;
        var_a0 = 1;
        temp_a1 = sSoundBanks[var_v0_3];
        temp_a1->prev = 0xFF;
        temp_a1->next = 0xFF;
loop_8:
        temp_lo = var_v1_2 * 0x30;
        temp_t4_3 = (var_v1_2 + 1) & 0xFF;
        temp_t9_2 = var_a0 - 1;
        temp_t3_2 = var_a0 + 1;
        var_a0 = temp_t4_3;
        var_v1_2 = temp_t4_3;
        temp_a1_2 = temp_a2 + temp_lo;
        temp_a1_2->unk2A = temp_t9_2;
        temp_a1_2->unk2B = temp_t3_2;
        if (temp_t4_3 < 0x13) {
            goto loop_8;
        }
        temp_t8 = (var_v0_3 + 1) & 0xFF;
        temp_at_3 = temp_t8 < 6;
        var_v0_3 = temp_t8;
        temp_a1_3 = &temp_a2[temp_t4_3];
        temp_a1_3->prev = temp_t4_3 - 1;
        temp_a1_3->next = 0xFF;
    } while (temp_at_3 != 0);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C5A3C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800CBBE8(s32, ?); // extern
extern ? D_800EA154;
extern u8 D_800EA1C0;
extern Player gPlayers;

void func_800C5BD0(void) {
    if (D_800EA1C0 == 0) {
        func_800CBBE8((*(&D_800EA154 + *(&gPlayers + 0x254)) << 8) | 0xF3000000, 0);
        return;
    }
    func_800CBBE8(0xF3004D00, 0);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C5BD0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C2474(); // extern
void func_800C284C(?, ?, ?, ?); // extern
void func_800C3F70(); // extern
void func_800C400C(); // extern
void func_800C5A3C(); // extern
void func_800C5BD0(); // extern
extern u8 D_800E9DA0;

void func_800C5C40(void) {
    u8 temp_v0;

    func_800C2474();
    temp_v0 = D_800E9DA0;
    if (temp_v0 != 0) {
        func_800C400C();
    } else {
        D_800E9DA0 = temp_v0 + 1;
        func_800C3F70();
    }
    func_800C5A3C();
    func_800C284C(2, 0, 0xFF, 1);
    func_800C5BD0();
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C5C40.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C2474(); // extern
void func_800C284C(u8, u8, u8, s32); // extern
void func_800C3F70(); // extern
void func_800C5A3C(); // extern

// game_audio_init?
void func_800C5CB8(void) {
    func_800C2474();
    func_800C3F70();
    func_800C5A3C();
    func_800C284C(2, 0, 255, 1);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C5CB8.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C94A4(u8);                                /* extern */
? func_800C97C4(s32, u8);                           /* extern */
static s32 D_800E9E24[4] = { 0, 0, 0, 0 };          /* const */
static s32 D_800E9E34[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; /* const */
static ? D_800EA0EC;                                /* unable to generate initializer; const */
static u8 D_800EA16C = 0;                           /* const */

void func_800C5D04(u8 arg0) {
    s32 *temp_a0;
    s32 *temp_v1_2;
    s32 temp_a0_2;
    s32 temp_t1;
    s32 var_v1;
    u8 *temp_v1;
    u8 temp_a1;
    u8 temp_v0;

    temp_a1 = arg0 & 0xFF;
    if ((*(&gPlayers->unk_044 + (temp_a1 * 0xDD8)) & 0x20) == 0x20) {
        D_800E9E34[temp_a1] = 0;
        temp_a0 = &D_800E9E24[temp_a1];
        var_v1 = *temp_a0;
        if (var_v1 < 0x4E20) {
            temp_t1 = var_v1 + 1;
            if (D_800EA16C == 0) {
                *temp_a0 = temp_t1;
                var_v1 = temp_t1;
            }
        }
        temp_v1 = temp_a1 + &D_800EA0EC;
        if (var_v1 == 1) {
            temp_v0 = *temp_v1;
            if (temp_v0 != 0) {
                if (temp_v0 == 2) {
                    *temp_v1 = 1;
                    goto block_8;
                }
            } else {
block_8:
                arg0 = temp_a1;
                func_800C97C4(temp_a1 & 0xFF, temp_a1);
                func_800C94A4(arg0);
            }
        }
    } else {
        D_800E9E24[temp_a1] = 0;
        temp_v1_2 = &D_800E9E34[temp_a1];
        temp_a0_2 = *temp_v1_2;
        if ((temp_a0_2 < 0x4E20) && (D_800EA16C == 0)) {
            *temp_v1_2 = temp_a0_2 + 1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C5D04.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C9018(s32, ?, u8, Player *);              /* extern */
? play_sound(?, void *, u8, void *, s32 *, void *); /* extern */
static ?32 D_800E9DC4[4] = { 0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000 }; /* const */
static ?32 D_800E9DD4[4] = { 0, 0, 0, 0 };          /* const */
static s32 D_800E9E14[4] = { 0, 0, 0, 0 };          /* const */
static s32 D_800E9E24[4] = { 0, 0, 0, 0 };          /* const */
static s32 D_800E9E34[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; /* const */
static s32 D_800E9F04[4] = { 0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000 }; /* const */
static f32 D_800E9F54[8] = { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static ? D_800E9F74;                                /* unable to generate initializer; const */
static ? D_800E9F7C;                                /* unable to generate initializer; const */
static ? D_800E9F8C;                                /* unable to generate initializer; const */
static ? D_800EA0EC;                                /* unable to generate initializer; const */
static ? D_800EA130;                                /* unable to generate initializer; const */
static u8 D_800EA16C = 0;                           /* const */
static u8 D_800EA1C0 = 0;                           /* const */
s8 D_800EA108 = 0;                                  /* const */

void func_800C5E38(u8 playerId) {
    s32 sp3C;
    Player *temp_a3;
    f32 temp_f0;
    f32 temp_f2;
    s32 temp_v0;
    u8 *temp_t0;
    u8 temp_v1;
    u8 var_a2;
    void *temp_a1;
    void *temp_a1_2;

    var_a2 = playerId & 0xFF;
    if ((u8) D_800EA108 == 0) {
        temp_a3 = &gPlayers[var_a2];
        temp_v0 = var_a2 * 4;
        if (((temp_a3->unk_044 & 0x20) != 0x20) && (temp_t0 = var_a2 + &D_800EA0EC, (temp_a3->unk_098 > 400.0f))) {
            D_800E9E14[var_a2] = 1;
            temp_v1 = *temp_t0;
            if (temp_v1 == 0) {
                *(&D_800E9F8C + (var_a2 * 0x3C)) = 0.6f - D_800E9F54[var_a2];
            }
            temp_a1 = (var_a2 * 0x3C) + &D_800E9F7C;
            D_800E9DC4[var_a2] = temp_a1->unk30;
            D_800E9DD4[var_a2] = temp_a1->unk24;
            if ((D_800E9E34[var_a2] == 1) && (D_800EA16C == 0)) {
                if (temp_v1 != 0) {
                    if (temp_v1 == 2) {
                        *temp_t0 = 1;
                        goto block_10;
                    }
                } else {
block_10:
                    if ((*(&D_800E9F74 + var_a2) == 0) && (temp_a3->characterId != 3)) {
                        if ((s32) D_800EA1C0 < 2) {
                            play_sound(0x0100F926, temp_a1, var_a2, temp_a1 + 0x38, &D_800E9F04[var_a2], temp_a1 + 0x14);
                            return;
                        }
                        play_sound(0x01008026, temp_a1, var_a2, temp_a1 + 0x38, &D_800E9F04[var_a2], temp_a1 + 0x14);
                    }
                }
            }
        } else {
            if (D_800E9E24[var_a2] == 0x0000000A) {
                if ((s32) D_800EA1C0 < 2) {
                    sp3C = temp_v0;
                    playerId = var_a2;
                    func_800C9018(var_a2 & 0xFF, 0x0100F926, var_a2, temp_a3);
                } else {
                    sp3C = temp_v0;
                    playerId = var_a2;
                    func_800C9018(var_a2 & 0xFF, 0x01008026, var_a2, temp_a3);
                }
                var_a2 = playerId;
            }
            *(D_800E9E14 + temp_v0) = 0;
            temp_f0 = 1.0f - *(D_800E9F54 + temp_v0);
            temp_f2 = *(&D_800EA130 + temp_v0);
            temp_a1_2 = (var_a2 * 0x3C) + &D_800E9F7C;
            temp_a1_2->unk10 = (f32) (temp_f0 - temp_f2);
            if (temp_f0 < temp_f2) {
                temp_a1_2->unk10 = 0.0f;
            }
            *(D_800E9DC4 + temp_v0) = temp_a1_2->unk2C;
            *(D_800E9DD4 + temp_v0) = temp_a1_2->unk20;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C5E38.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
static f32 D_800E9DC4[4] = { 1.0f, 1.0f, 1.0f, 1.0f }; /* const */
static f32 D_800E9DD4[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static f32 D_800E9DE4[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static f32 D_800E9DF4[8] = { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static f32 D_800E9E54[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static f32 D_800E9E64[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static f32 D_800E9EB4[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static f32 D_800E9EC4[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static f32 D_800E9ED4[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static f32 D_800E9EE4[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static f32 D_800E9F34[8] = { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static ? D_800E9F74;                                /* unable to generate initializer; const */
static ? D_800E9F78;                                /* unable to generate initializer; const */
static ? D_800E9F7C;                                /* unable to generate initializer; const */

void func_800C6108(s32 playerId) {
    Player *temp_v1;
    f32 *temp_a2_2;
    f32 *temp_a3;
    f32 *temp_t0;
    f32 *temp_v1_3;
    f32 *temp_v1_4;
    f32 *temp_v1_5;
    f32 *var_a0;
    f32 *var_t0;
    f32 *var_t2;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f12;
    f32 temp_f2;
    s16 temp_t1;
    s32 temp_a2;
    u8 *temp_a3_2;
    u8 temp_t0_2;
    u8 temp_v1_2;
    void *temp_a1;
    void *temp_a1_2;

    temp_a2 = playerId & 0xFF;
    unksp-10.unk10 = playerId;
    temp_v1 = &gPlayers[temp_a2];
    temp_f0 = temp_v1->unk_098;
    temp_a3 = &D_800E9E64[temp_a2];
    *temp_a3 = D_800E9DD4[temp_a2] + (temp_f0 / D_800E9DC4[temp_a2]);
    if ((temp_f0 < 1800.0f) && ((temp_v1->unk_044 & 0x20) != 0x20)) {
        temp_a1 = (temp_a2 * 0x3C) + &D_800E9F7C;
        *temp_a3 = temp_a1->unk28 + (temp_f0 / temp_a1->unk34);
    }
    temp_a1_2 = (temp_a2 * 0x3C) + &D_800E9F7C;
    if (temp_v1->unk_094 > 4.75f) {
        var_a0 = &D_800E9EB4[temp_a2];
        temp_t0 = &D_800E9DE4[temp_a2];
        if (*var_a0 < (temp_a1_2->unk18 + 0.4f)) {
            *temp_t0 += 0.005f;
        }
        var_t0 = &D_800E9DE4[temp_a2];
    } else {
        var_t0 = &D_800E9DE4[temp_a2];
        var_a0 = &D_800E9EB4[temp_a2];
        *var_t0 = 0.0f;
    }
    temp_t1 = temp_v1->unk_0C0;
    if (temp_t1 > 0) {
        var_t2 = &D_800E9E54[temp_a2];
        *var_t2 = (f32) temp_t1;
    } else {
        var_t2 = &D_800E9E54[temp_a2];
        *var_t2 = (f32) -temp_t1;
    }
    if ((temp_v1->unk_0BC & 0x10) == 0x10) {
        *var_a0 = *var_t0 + *temp_a3;
    } else {
        temp_f0_2 = (*temp_a3 + *var_t0) - (*var_t2 / 12000.0f);
        *var_a0 = temp_f0_2;
        if (temp_f0_2 < 0.01f) {
            *var_a0 = 0.01f;
        }
    }
    temp_v1_2 = *(&D_800E9F74 + temp_a2);
    temp_a3_2 = temp_a2 + &D_800E9F78;
    if ((temp_v1_2 != 0) || (*(&D_800E9F78 + temp_a2) != 0)) {
        temp_t0_2 = *temp_a3_2;
        if (temp_v1_2 != 0) {
            if ((s32) temp_t0_2 < 0xF) {
                *temp_a3_2 = temp_t0_2 + 1;
                temp_v1_3 = &D_800E9DF4[temp_a2];
                *temp_v1_3 += 0.03f;
            }
        } else if (temp_t0_2 != 0) {
            *temp_a3_2 = temp_t0_2 - 1;
            temp_v1_4 = &D_800E9DF4[temp_a2];
            *temp_v1_4 -= 0.03f;
        }
        *var_a0 -= D_800E9DF4[temp_a2];
    }
    temp_a2_2 = &D_800E9EC4[temp_a2];
    temp_f2 = *temp_a2_2;
    temp_f0_3 = *var_a0;
    temp_f12 = temp_f0_3 - temp_f2;
    temp_v1_5 = &D_800E9EE4[temp_a2];
    *temp_v1_5 = temp_f12;
    if ((temp_f12 > 0.5f) || (*temp_v1_5 < 0.5f)) {
        temp_f0_4 = *temp_v1_5 * 0.25f;
        D_800E9ED4[temp_a2] = temp_f0_4;
        temp_a1_2->unkC = (f32) (D_800E9F34[temp_a2] + (temp_f2 + temp_f0_4));
    } else {
        temp_a1_2->unkC = (f32) (D_800E9F34[temp_a2] + temp_f0_3);
    }
    if (temp_a1_2->unkC > 4.0f) {
        temp_a1_2->unkC = 4.0f;
    }
    *temp_a2_2 = temp_a1_2->unkC;
    temp_a1_2->unk38 = (f32) ((temp_a1_2->unkC / 1.5f) + 0.4f);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C6108.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
static s32 D_800E9E24[4] = { 0, 0, 0, 0 };          /* const */
static s32 D_800E9E34[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; /* const */
static f32 D_800E9E54[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static s32 D_800E9E74[4] = { 0, 0, 0, 0 };          /* const */
static f32 D_800E9EF4[4] = { 1.0f, 1.0f, 1.0f, 1.0f }; /* const */
static f32 D_800E9F04[4] = { 1.0f, 1.0f, 1.0f, 1.0f }; /* const */
static ? D_800E9F24;                                /* unable to generate initializer; const */

void func_800C64A0(s32 playerId) {
    f32 *var_v1;
    f32 *var_v1_2;
    f32 var_f16;
    s32 temp_t6;
    s32 temp_t7;

    temp_t6 = playerId & 0xFF;
    unksp-10.unk10 = playerId;
    temp_t7 = D_800E9E74[temp_t6];
    switch (temp_t7) {
    case 3:
        var_v1 = &D_800E9EF4[temp_t6];
        *var_v1 = (gPlayers[temp_t6].unk_094 / 5.0f) + 0.2f;
        break;
    case 1:
    case 13:
    case 14:
    case 17:
        var_v1 = &D_800E9EF4[temp_t6];
        *var_v1 = ((D_800E9E54[temp_t6] - 3500.0f) / 3000.0f) + 0.4f;
        break;
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 22:
    case 23:
    case 24:
    case 29:
    case 30:
    case 31:
        var_v1 = &D_800E9EF4[temp_t6];
        *var_v1 = (gPlayers[temp_t6].unk_094 / 5.0f) + 0.2f;
        break;
    default:
        var_v1 = &D_800E9EF4[temp_t6];
        *var_v1 = 1.0f;
        break;
    }
    if (*var_v1 > 1.0f) {
        *var_v1 = 1.0f;
    }
    if (*var_v1 < 0.0f) {
        *var_v1 = 0.0f;
    }
    if ((gPlayers[temp_t6].unk_044 & 0x20) == 0x20) {
        var_v1_2 = &D_800E9F04[temp_t6];
        var_f16 = 0.56f - ((f32) D_800E9E24[temp_t6] * 0.06f);
    } else {
        var_v1_2 = &D_800E9F04[temp_t6];
        var_f16 = ((f32) D_800E9E34[temp_t6] / 50.0f) + 0.25f;
    }
    *var_v1_2 = var_f16;
    if (*(&D_800E9F24 + temp_t6) != 0) {
        *var_v1_2 = 0.0f;
    }
    if (*var_v1_2 > 0.9f) {
        *var_v1_2 = 0.9f;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C64A0.s")
#endif

void func_800C6758(u8 playerId) {
    switch (D_800E9E74[playerId]) {                              /* irregular */
    case 3:
        D_800E9F14[playerId] = (gPlayers[playerId].unk_094 / 9.0f) + 0.6f;
        break;
    case 2:
    case 13:
    case 17:
        D_800E9F14[playerId] = (D_800E9E54[playerId] / 13000.0f) + 0.95f;
        break;
    default:
        D_800E9F14[playerId] = 1.0f;
        break;
    }
}

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C5578(f32 *, s32, u8);                    /* extern */
static s32 D_800E9E84[4] = { 0, 0, 0, 0 };          /* const */
static s32 D_800E9E94[4] = { 0, 0, 0, 0 };          /* const */
static f32 D_800E9EF4[4] = { 1.0f, 1.0f, 1.0f, 1.0f }; /* const */
static ? D_800E9F7C;                                /* unable to generate initializer; const */
static ? D_800EA0EC;                                /* unable to generate initializer; const */
s32 D_800E9E74[4] = { 0, 0, 0, 0 };                 /* const */
f32 D_800E9F14[4] = { 1.0f, 1.0f, 1.0f, 1.0f };     /* const */
u8 D_800EA108 = 0;                                  /* const */

void func_800C683C(u8 arg0) {
    s32 sp4C;
    s32 *sp40;
    f32 *temp_s0;
    s32 *temp_s1;
    s32 *temp_s2;
    s32 *temp_t0;
    s32 temp_t6;
    u8 temp_a2;

    temp_a2 = arg0 & 0xFF;
    if ((D_800EA108 == 0) && (*(&D_800EA0EC + temp_a2) == 0)) {
        temp_t0 = &D_800E9E84[temp_a2];
        sp40 = temp_t0;
        temp_s2 = &D_800E9E74[temp_a2];
        if (*temp_s2 != *temp_t0) {
            temp_s0 = (temp_a2 * 0x3C) + &D_800E9F7C;
            temp_s1 = &D_800E9E94[temp_a2];
            sp4C = temp_a2 * 4;
            arg0 = temp_a2;
            func_800C5578(temp_s0, *temp_s1, temp_a2);
            temp_t6 = *temp_s2;
            switch (temp_t6) {
            case 3:
                play_sound(0x0100F908U, temp_s0, arg0, &D_800E9F14[temp_a2], &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F908;
                break;
            case 18:
                play_sound(0x0100F81DU, temp_s0, arg0, &D_800EA1D4, &D_800EA1D4, (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F81D;
                break;
            case 19:
                play_sound(0x0100F822U, temp_s0, arg0, &D_800EA1D4, &D_800EA1D4, (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F822;
                break;
            case 1:
                play_sound(0x0100F009U, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F009;
                break;
            case 2:
                play_sound(0x0100F40AU, temp_s0, arg0, &D_800E9F14[temp_a2], &D_800EA1D4, (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F40A;
                break;
            case 17:
                play_sound(0x0100F01EU, temp_s0, arg0, &D_800E9F14[temp_a2], &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F01E;
                break;
            case 15:
                play_sound(0x0100F01FU, temp_s0, arg0, &D_800E9F14[temp_a2], &D_800EA1D4, (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F01F;
                break;
            case 16:
                play_sound(0x0100F021U, temp_s0, arg0, &D_800E9F14[temp_a2], &D_800EA1D4, (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F021;
                break;
            case 20:
                play_sound(0x0100F027U, temp_s0, arg0, &D_800E9F14[temp_a2], &D_800EA1D4, (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F027;
                break;
            case 25:
                play_sound(0x0100F020U, temp_s0, arg0, &D_800E9F14[temp_a2], &D_800EA1D4, (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F020;
                break;
            case 26:
                play_sound(0x0100F023U, temp_s0, arg0, &D_800E9F14[temp_a2], &D_800EA1D4, (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F023;
                break;
            case 27:
                play_sound(0x01008046U, temp_s0, arg0, &D_800E9F14[temp_a2], &D_800EA1D4, (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x01008046;
                break;
            case 28:
                play_sound(0x0100F025U, temp_s0, arg0, &D_800E9F14[temp_a2], &D_800EA1D4, (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F025;
                break;
            case 4:
                play_sound(0x0100F00BU, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F00B;
                break;
            case 5:
                play_sound(0x0100F00CU, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F00C;
                break;
            case 6:
                play_sound(0x0100F00DU, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F00D;
                break;
            case 7:
                play_sound(0x0100F00EU, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F00E;
                break;
            case 8:
                play_sound(0x0100F00FU, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F00F;
                break;
            case 9:
                play_sound(0x0100F010U, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F010;
                break;
            case 10:
            case 14:
                play_sound(0x0100F011U, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F011;
                break;
            case 11:
                play_sound(0x0100F012U, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F012;
                break;
            case 12:
                play_sound(0x0100F013U, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F013;
                break;
            case 29:
                play_sound(0x0100F048U, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F048;
                break;
            case 30:
                play_sound(0x0100F049U, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F049;
                break;
            case 31:
                play_sound(0x0100F04AU, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F04A;
                break;
            case 13:
            case 22:
                play_sound(0x0100F029U, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F029;
                break;
            case 23:
                play_sound(0x0100F02AU, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F02A;
                break;
            case 24:
                play_sound(0x0100F02BU, temp_s0, arg0, &D_800EA1D4, &D_800E9EF4[temp_a2], (u8 *) (temp_s0 + 0x14));
                *temp_s1 = 0x0100F02B;
                break;
            default:
                func_800C5578(temp_s0, *temp_s1, arg0);
                break;
            }
        }
        *sp40 = *temp_s2;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C683C.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
static f32 D_800E9E54[4] = { 0.0f, 0.0f, 0.0f, 0.0f }; /* const */
static s32 D_800E9E74[4] = { 0, 0, 0, 0 };          /* const */
static u8 D_800E9F74;                                /* unable to generate initializer; const */
static u8 D_800EA0EC;                                /* unable to generate initializer; const */
static u8 D_800EA1C0 = 0;                           /* const */

void func_800C70A8(s32 playerId) {
    Player *temp_v1;
    s32 *temp_v0;
    s32 temp_a1;
    s32 var_a0;
    s32 var_t1;
    u8 temp_t2;
    u8 temp_t7;
    u8 temp_t9;

    temp_a1 = playerId & 0xFF;
    unksp-10.unk10 = playerId;
    if (*(&D_800EA0EC + temp_a1) == 0) {
        temp_v0 = &D_800E9E74[temp_a1];
        *temp_v0 = 0;
        if ((D_800E9E54[temp_a1] > 3500.0f) || (var_a0 = gPlayers[temp_a1].unk_0BC, var_t1 = var_a0 & 0x10, (var_t1 == 0x10))) {
            temp_v1 = &gPlayers[temp_a1];
            temp_t7 = temp_v1->boundingBoxCorners[2].surfaceType;
            var_a0 = temp_v1->unk_0BC;
            *temp_v0 = 1;
            var_t1 = var_a0 & 0x10;
            switch (temp_t7) {                      /* switch 1 */
            case 2:                                 /* switch 1 */
                *temp_v0 = 0x0000000D;
                break;
            case 3:                                 /* switch 1 */
                *temp_v0 = 0x0000000E;
                break;
            case 6:                                 /* switch 1 */
                *temp_v0 = 0x00000011;
                break;
            case 4:                                 /* switch 1 */
                *temp_v0 = 0x0000000F;
                break;
            case 5:                                 /* switch 1 */
                *temp_v0 = 0x00000010;
                break;
            case 9:                                 /* switch 1 */
                *temp_v0 = 0x00000014;
                break;
            case 16:                                /* switch 1 */
                *temp_v0 = 0x00000019;
                break;
            case 17:                                /* switch 1 */
                *temp_v0 = 0x0000001A;
                break;
            case 14:                                /* switch 1 */
                *temp_v0 = 0x0000001B;
                break;
            }
        }
        temp_t2 = gPlayers[temp_a1].boundingBoxCorners[2].surfaceType;
        if (var_t1 == 0x10) {
            *temp_v0 = 2;
            switch (temp_t2) {                      /* switch 2 */
            case 2:                                 /* switch 2 */
                *temp_v0 = 0x0000000D;
                break;
            case 3:                                 /* switch 2 */
                *temp_v0 = 0x0000000E;
                break;
            case 6:                                 /* switch 2 */
                *temp_v0 = 0x00000011;
                break;
            case 4:                                 /* switch 2 */
                *temp_v0 = 0x0000000F;
                break;
            case 5:                                 /* switch 2 */
                *temp_v0 = 0x00000010;
                break;
            case 9:                                 /* switch 2 */
                *temp_v0 = 0x00000014;
                break;
            case 16:                                /* switch 2 */
                *temp_v0 = 0x00000019;
                break;
            case 17:                                /* switch 2 */
                *temp_v0 = 0x0000001A;
                break;
            case 14:                                /* switch 2 */
                *temp_v0 = 0x0000001B;
                break;
            }
        }
        switch (temp_t2) {                          /* switch 3 */
        case 8:                                     /* switch 3 */
            if (*temp_v0 == 6) {
                *temp_v0 = 4;
            } else if (D_800EA1C0 == 0) {
                *temp_v0 = 5;
            } else {
                *temp_v0 = 4;
            }
            break;
        case 7:                                     /* switch 3 */
            if (*temp_v0 == 0x0000000C) {
                *temp_v0 = 0x0000000A;
            } else if (D_800EA1C0 == 0) {
                *temp_v0 = 0x0000000B;
            } else {
                *temp_v0 = 0x0000000A;
            }
            break;
        case 13:                                    /* switch 3 */
            if (*temp_v0 == 0x00000018) {
                *temp_v0 = 0x00000016;
            } else if (D_800EA1C0 == 0) {
                *temp_v0 = 0x00000017;
            } else {
                *temp_v0 = 0x00000016;
            }
            break;
        case 11:                                    /* switch 3 */
            if (*temp_v0 == 0x0000001F) {
                *temp_v0 = 0x0000001D;
            } else if (D_800EA1C0 == 0) {
                *temp_v0 = 0x0000001E;
            } else {
                *temp_v0 = 0x0000001D;
            }
            break;
        case 10:                                    /* switch 3 */
            if (*(&D_800E9F74 + temp_a1) == 0) {
                if (*temp_v0 == 9) {
                    *temp_v0 = 7;
                } else if (D_800EA1C0 == 0) {
                    *temp_v0 = 8;
                } else {
                    *temp_v0 = 7;
                }
            } else {
                *temp_v0 = 0x0000001C;
            }
            break;
        case 16:                                    /* switch 3 */
            *temp_v0 = 0x00000019;
            break;
        case 17:                                    /* switch 3 */
            *temp_v0 = 0x0000001A;
            break;
        case 14:                                    /* switch 3 */
            *temp_v0 = 0x0000001B;
            break;
        }
        temp_t9 = gPlayers[temp_a1].boundingBoxCorners[3].surfaceType;
        switch (temp_t9) {                          /* switch 4 */
        case 8:                                     /* switch 4 */
            if (*temp_v0 == 5) {
                *temp_v0 = 4;
            } else if (D_800EA1C0 == 0) {
                *temp_v0 = 6;
            } else {
                *temp_v0 = 4;
            }
            break;
        case 7:                                     /* switch 4 */
            if (*temp_v0 == 0x0000000B) {
                *temp_v0 = 0x0000000A;
            } else if (D_800EA1C0 == 0) {
                *temp_v0 = 0x0000000C;
            } else {
                *temp_v0 = 0x0000000A;
            }
            break;
        case 13:                                    /* switch 4 */
            if (*temp_v0 == 0x00000017) {
                *temp_v0 = 0x00000016;
            } else if (D_800EA1C0 == 0) {
                *temp_v0 = 0x00000018;
            } else {
                *temp_v0 = 0x00000016;
            }
            break;
        case 11:                                    /* switch 4 */
            if (*temp_v0 == 0x0000001E) {
                *temp_v0 = 0x0000001D;
            } else if (D_800EA1C0 == 0) {
                *temp_v0 = 0x0000001F;
            } else {
                *temp_v0 = 0x0000001D;
            }
            break;
        case 10:                                    /* switch 4 */
            if (*(&D_800E9F74 + temp_a1) == 0) {
                if (*temp_v0 == 8) {
                    *temp_v0 = 7;
                } else if (D_800EA1C0 == 0) {
                    *temp_v0 = 9;
                } else {
                    *temp_v0 = 7;
                }
            } else {
                *temp_v0 = 0x0000001C;
            }
            break;
        case 16:                                    /* switch 4 */
            *temp_v0 = 0x00000019;
            break;
        case 17:                                    /* switch 4 */
            *temp_v0 = 0x0000001A;
            break;
        case 14:                                    /* switch 4 */
            *temp_v0 = 0x0000001B;
            break;
        }
        if (((gPlayers[temp_a1].unk_094 < 0.5f) || ((var_a0 & 8) == 8)) && (*temp_v0 != 0x0000001C)) {
            *temp_v0 = 0;
        }
        if ((((var_a0 & 0x4000) == 0x4000) && ((gPlayers[temp_a1].unk_000 & 0x2000) != 0x2000)) || ((var_a0 & 0x800) == 0x800) || ((var_a0 & 0x80) == 0x80) || ((var_a0 & 0x40) == 0x40) || ((gPlayers[temp_a1].unk_044 & 0x4000) == 0x4000)) {
            *temp_v0 = 0x00000012;
        }
        if ((((var_a0 & 0x20) == 0x20) && ((gPlayers[temp_a1].unk_000 & 0x2000) != 0x2000)) || ((var_a0 & 0x800) == 0x800)) {
            *temp_v0 = 0x00000013;
        }
        if (gPlayers[temp_a1].unk_20C != 0.0f) {
            *temp_v0 = 3;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C70A8.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C3448(?, ?);                              /* extern */
s32 func_800C3508(?);                               /* extern */
? func_800C5278(?);                                 /* extern */
? func_800C5578(void *, s32);                       /* extern */
? func_800C9018(u8, ?);                             /* extern */
? func_800C97C4(u8);                                /* extern */
? func_800C9A88(u8);                                /* extern */
? func_800C9D0C(u8);                                /* extern */
? func_800CA414(?, ?);                              /* extern */
extern s8 D_801657E5;
extern u8 D_8018ED90;
extern s32 gPlayerWinningIndex;
static ? D_800E9E74;                                /* unable to generate initializer; const */
static ? D_800E9E94;                                /* unable to generate initializer; const */
static s32 D_800E9EA4[4] = { 0, 0, 0, 0 };          /* const */
static ? D_800E9F7C;                                /* unable to generate initializer; const */
static ? D_800EA0EC;                                /* unable to generate initializer; const */
static u8 D_800EA0ED = 0;                           /* const */
static u8 D_800EA0EE = 0;                           /* const */
static u8 D_800EA0EF = 0;                           /* const */
static s8 D_800EA0F0 = 0;                           /* const */
static u8 D_800EA104 = 0;                           /* const */
static ? D_800EA130;                                /* unable to generate initializer; const */
static u8 D_800EA1C0 = 0;                           /* const */

void func_800C76C0(u8 playerId) {
    s32 sp38;
    s32 *sp34;
    u8 *sp30;
    Player *temp_v1;
    Player *temp_v1_2;
    f32 *var_at;
    f32 var_f10;
    s16 temp_v0_11;
    s16 temp_v0_12;
    s16 temp_v0_3;
    s16 temp_v0_4;
    s32 *temp_t0;
    s32 temp_t1;
    s32 temp_v0;
    s32 temp_v0_10;
    s32 temp_v1_3;
    s32 temp_v1_4;
    s32 temp_v1_5;
    s32 temp_v1_6;
    s32 var_v1;
    s8 *temp_a2;
    u8 *temp_v0_2;
    u8 *temp_v0_5;
    u8 temp_t6;
    u8 temp_v0_6;
    u8 temp_v0_7;
    u8 temp_v0_8;
    u8 temp_v0_9;
    u8 var_a0;
    u8 var_v0;

    temp_t6 = playerId & 0xFF;
    temp_t0 = &D_800E9EA4[temp_t6];
    sp34 = temp_t0;
    sp38 = temp_t6 * 4;
    var_v1 = *temp_t0;
    if (var_v1 != 0) {
        temp_t1 = var_v1 + 1;
        if (var_v1 < 0x2BC) {
            *temp_t0 = temp_t1;
            var_v1 = temp_t1;
        }
        playerId = temp_t6;
        if (var_v1 == 2) {
            playerId = temp_t6;
            func_800C9018(temp_t6, 0x0100FA28);
            func_800C9018(playerId, 0x0100FF2C);
            func_800C9018(playerId, 0x0100FA4C);
            func_800C5578((playerId * 0x3C) + &D_800E9F7C, *(&D_800E9E94 + sp38));
            temp_v0 = gModeSelection;
            *(&D_800E9E74 + sp38) = 0;
            switch (temp_v0) {                      /* irregular */
            case 0:
                temp_v0_2 = playerId + &D_800EA0EC;
                *temp_v0_2 = 2;
                sp30 = temp_v0_2;
                func_800C9060(playerId, 0x1900F103U);
                if (D_800EA1C0 == 0) {
                    func_800C3448(0x100100FF);
                    func_800C3448(0x110100FF);
                    func_800C5278(5);
                    temp_v0_3 = *(&gPlayers->currentRank + (playerId * 0xDD8));
                    if (temp_v0_3 == 0) {
                        func_800C97C4(playerId);
                        D_800EA0F0 = 2;
                        func_800C9A88(playerId);
                        func_800CA414(0xD, 0x10);
                    } else if (temp_v0_3 < 4) {
                        func_800C97C4(playerId);
                        D_800EA0F0 = 2;
                        func_800C9A88(playerId);
                        func_800CA414(0xE, 0x10);
                    } else {
                        func_800C3448(0xC1606400);
                        func_800CA414(0xF, 0x18);
                    }
                } else {
                    *sp30 = 2;
                    func_800C9060(playerId, 0x1900F103U);
                    temp_v0_4 = *(&gPlayers->currentRank + (playerId * 0xDD8));
                    if (temp_v0_4 == 0) {
                        func_800C3448(0x100100FF);
                        func_800C3448(0x110100FF);
                        func_800C97C4(playerId);
                        D_800EA0F0 = 2;
                        func_800C9A88(playerId);
                        func_800CA414(0xD, 0x10);
                        goto block_23;
                    }
                    if (temp_v0_4 < 4) {
                        if (D_800EA104 == 0) {
                            func_800C3448(0x100100FF);
                            func_800C3448(0x110100FF);
                        }
                        func_800C97C4(playerId);
                        D_800EA0F0 = 2;
                        func_800C9A88(playerId);
                        func_800CA414(0xE, 0x10);
                        goto block_23;
                    }
                    var_v0 = D_800EA104;
                    if (var_v0 == 0) {
                        func_800C3448(0x100100FF);
                        func_800C3448(0x110100FF);
                        func_800C3448(0xC1606400);
                        func_800CA414(0xF, 0x18);
block_23:
                        var_v0 = D_800EA104;
                    }
                    if ((var_v0 != 0) || (*sp30 != 1)) {
                        func_800C5278(5);
                    }
                }
                var_v1 = *sp34;
                break;
            case 1:
                func_800C3448(0x100100FF);
                func_800C3448(0x110100FF);
                func_800C97C4(playerId);
                D_800EA0F0 = 2;
                func_800C9A88(0U);
                *(&D_800EA0EC + playerId) = 2;
                func_800C9060(playerId, 0x1900F103U);
                if (D_801657E5 == 1) {
                    func_800CA414(0xD, 0x10);
                } else if (D_8018ED90 == 1) {
                    func_800CA414(0xE, 0x10);
                } else {
                    func_800C3448(0x01640010, 0x10);
                }
                var_v1 = *sp34;
                break;
            case 2:
                temp_v0_5 = playerId + &D_800EA0EC;
                *temp_v0_5 = 2;
                sp30 = temp_v0_5;
                func_800C9060(playerId, 0x1900F103U);
                temp_v0_6 = D_800EA1C0;
                switch (temp_v0_6) {                /* switch 1; irregular */
                case 1:                             /* switch 1 */
                    func_800C3448(0x100100FF);
                    func_800C3448(0x110100FF);
                    func_800C97C4(playerId);
                    D_800EA0F0 = 2;
                    func_800C9A88(playerId);
                    func_800CA414(0xD, 0x17);
                    break;
                case 2:                             /* switch 1 */
                    temp_v0_7 = D_800EA104;
                    if ((temp_v0_7 == 0) && (*sp30 == 1)) {
                        func_800C3448(0x100100FF);
                        func_800C3448(0x110100FF);
                        func_800CA414(0xD, 0x17);
                        D_800EA104 = 1;
                    } else if ((temp_v0_7 == 1) && (*sp30 == 1)) {
                        func_800C5278(5);
                        if (func_800C3508(1) != 0xD) {
                            D_800EA104 = 0;
                            func_800CA414(0xE, 0x17);
                        }
                        D_800EA104 = 2;
                    }
                    break;
                case 3:                             /* switch 1 */
                    temp_v0_8 = D_800EA104;
                    if ((temp_v0_8 == 0) && (*sp30 == 1)) {
                        func_800C3448(0x100100FF);
                        func_800C3448(0x110100FF);
                        func_800C8EF8(0xD);
                        D_800EA104 = 1;
                    } else if ((temp_v0_8 == 1) && (*sp30 == 1)) {
                        if (func_800C3508(1) != 0xD) {
                            D_800EA104 = 0;
                            func_800C8EF8(0xE);
                        }
                        D_800EA104 = 2;
                    } else if ((temp_v0_8 == 2) && (*sp30 == 1)) {
                        func_800C5278(5);
                        if (func_800C3508(1) != 0xE) {
                            D_800EA104 = 0;
                            func_800CA414(0xE, 0x17);
                        }
                        D_800EA104 = 3;
                    }
                    break;
                }
            default:
block_76:
                var_v1 = *sp34;
                break;
            case 3:
                temp_v0_9 = D_800EA1C0;
                switch (temp_v0_9) {                /* switch 2; irregular */
                case 1:                             /* switch 2 */
                    func_800C3448(0x100100FF);
                    func_800C3448(0x110100FF);
                    func_800C5278(5);
                    func_800C9018(playerId, 0x0100F926);
                    func_800C8EF8(0x17);
                    *(&D_800EA0EC + playerId) = 2;
                    func_800C90F4(playerId, (*(&gPlayers->characterId + (gPlayerWinningIndex * 0xDD8)) * 0x10) + 0x2900800D);
                    break;
                case 2:                             /* switch 2 */
                    if ((D_800EA0EC.unk0 == 1) && (D_800EA0EC.unk1 == 1) && (D_800EA0EC.unk2 == 1)) {
                        func_800C5278(5);
                        func_800C9018(playerId, 0x01008026);
                        func_800C8EF8(0x17);
                        *(&D_800EA0EC + playerId) = 2;
                        func_800C90F4(playerId, (*(&gPlayers->characterId + (gPlayerWinningIndex * 0xDD8)) * 0x10) + 0x2900800D);
                    }
                    break;
                case 3:                             /* switch 2 */
                    if ((D_800EA0EC.unk0 == 1) && (D_800EA0ED == 1) && (D_800EA0EE == 1) && (D_800EA0EF == 1)) {
                        func_800C5278(5);
                        func_800C9018(playerId, 0x01008026);
                        func_800C8EF8(0x17);
                        *(&D_800EA0EC + playerId) = 2;
                        func_800C90F4(playerId, (*(&gPlayers->characterId + (gPlayerWinningIndex * 0xDD8)) * 0x10) + 0x2900800D);
                    }
                    break;
                }
                goto block_76;
            }
        }
        var_a0 = playerId;
        temp_v0_10 = gModeSelection;
        if (var_v1 == 0x0000001E) {
            switch (temp_v0_10) {                   /* switch 3; irregular */
            case 3:                                 /* switch 3 */
                break;
            case 0:                                 /* switch 3 */
                temp_v1 = &gPlayers[var_a0];
                temp_v0_11 = temp_v1->currentRank;
                temp_a2 = var_a0 + &D_800EA0EC;
                if (temp_v0_11 == 0) {
                    *temp_a2 = 2;
                    playerId = var_a0;
                    func_800C90F4(var_a0, (temp_v1->characterId * 0x10) + 0x29008007);
                } else if (temp_v0_11 < 4) {
                    *temp_a2 = 2;
                    playerId = var_a0;
                    func_800C90F4(var_a0, (temp_v1->characterId * 0x10) + 0x2900800D);
                } else {
                    *temp_a2 = 2;
                    playerId = var_a0;
                    func_800C90F4(var_a0, (temp_v1->characterId * 0x10) + 0x29008003);
                }
block_97:
                var_a0 = playerId;
                break;
            case 2:                                 /* switch 3 */
                temp_v1_2 = &gPlayers[var_a0];
                playerId = var_a0;
                if (temp_v1_2->currentRank == 0) {
                    *(&D_800EA0EC + var_a0) = 2;
                    playerId = var_a0;
                    func_800C90F4(var_a0, (temp_v1_2->characterId * 0x10) + 0x2900800D);
                }
                goto block_97;
            case 1:                                 /* switch 3 */
                if (D_801657E5 == 1) {
                    *(&D_800EA0EC + var_a0) = 2;
                    playerId = var_a0;
                    func_800C90F4(var_a0, (*(&gPlayers->characterId + (var_a0 * 0xDD8)) * 0x10) + 0x29008007);
                } else {
                    playerId = var_a0;
                    if (D_8018ED90 == (u8) 1) {
                        *(&D_800EA0EC + var_a0) = 2;
                        playerId = var_a0;
                        func_800C90F4(var_a0, (*(&gPlayers->characterId + (var_a0 * 0xDD8)) * 0x10) + 0x2900800D);
                    }
                }
                goto block_97;
            }
        }
        switch (gModeSelection) {                   /* switch 4; irregular */
        case 0:                                     /* switch 4 */
            temp_v0_12 = *(&gPlayers->currentRank + (var_a0 * 0xDD8));
            temp_v1_3 = *sp34;
            if (temp_v0_12 == 0) {
                if (temp_v1_3 >= 0x15F) {
                    if (temp_v1_3 == 0x0000015F) {
                        func_800C9D0C(var_a0);
                        return;
                    }
                } else {
                    var_at = &D_800EA130 + sp38;
                    var_f10 = (f32) temp_v1_3 / 400.0f;
block_134:
                    *var_at = var_f10;
                }
            } else if (temp_v0_12 < 4) {
                if (temp_v1_3 >= 0x15F) {
                    if (temp_v1_3 == 0x0000015F) {
                        func_800C9D0C(var_a0);
                        return;
                    }
                } else {
                    *(&D_800EA130 + sp38) = (f32) temp_v1_3 / 400.0f;
                    return;
                }
            } else if (temp_v1_3 >= 0x12D) {
                if (temp_v1_3 == 0x0000012D) {
                    func_800C97C4(var_a0);
                    return;
                }
            } else {
                *(&D_800EA130 + sp38) = (f32) temp_v1_3 / 330.0f;
                return;
            }
            break;
        case 2:                                     /* switch 4 */
            temp_v1_4 = *sp34;
            if (D_800EA1C0 == (u8) 1) {
                if (temp_v1_4 >= 0x65) {
                    if (temp_v1_4 == 0x00000065) {
                        func_800C9D0C(var_a0);
                    }
                } else {
                    *(&D_800EA130 + sp38) = (f32) temp_v1_4 / 120.0f;
                }
            } else if (temp_v1_4 >= 0x65) {
                if (temp_v1_4 == 0x00000065) {
                    func_800C97C4(var_a0);
                }
            } else {
                *(&D_800EA130 + sp38) = (f32) temp_v1_4 / 120.0f;
            }
            /* fallthrough */
        case 1:                                     /* switch 4 */
            temp_v1_5 = *sp34;
            if (temp_v1_5 >= 0x12D) {
                if (temp_v1_5 == 0x0000012D) {
                    func_800C9D0C(0U);
                    return;
                }
            } else {
                *(&D_800EA130 + sp38) = (f32) temp_v1_5 / 350.0f;
                return;
            }
            break;
        case 3:                                     /* switch 4 */
            temp_v1_6 = *sp34;
            if (temp_v1_6 >= 0x65) {
                if (temp_v1_6 == 0x00000065) {
                    func_800C97C4(var_a0);
                    return;
                }
            } else {
                var_at = &D_800EA130 + sp38;
                var_f10 = (f32) temp_v1_6 / 120.0f;
                goto block_134;
            }
            break;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C76C0.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C9018(s32, ?);                            /* extern */
? func_800C94A4(s32);                               /* extern */
? func_800C97C4(s32);                               /* extern */
? play_sound(s32, void *, s32, ? *, ? *, void *);   /* extern */
static ? D_800E9F74;                                /* unable to generate initializer; const */
static ? D_800E9F7C;                                /* unable to generate initializer; const */
static ? D_800EA0EC;                                /* unable to generate initializer; const */
static u8 D_800EA1C0 = 0;                           /* const */
static ? D_800EA1D4;                                /* unable to generate initializer; const */
s16 gCurrentCourseId;                               /* unable to generate initializer */

void func_800C847C(s32 playerId) {
    Player *sp3C;
    u8 *sp38;
    Player *temp_t8;
    s16 temp_v0_2;
    s32 temp_s0;
    u8 *temp_v0;
    u8 *temp_v0_3;
    void *temp_a1;
    void *temp_a1_2;

    temp_s0 = playerId & 0xFF;
    temp_t8 = &gPlayers[temp_s0];
    sp3C = temp_t8;
    if ((temp_t8->unk_0DE & 1) == 1) {
        temp_v0 = temp_s0 + &D_800E9F74;
        if (*temp_v0 == 0) {
            if ((s32) D_800EA1C0 < 2) {
                sp38 = temp_v0;
                func_800C9018(temp_s0 & 0xFF, 0x0100F926);
            } else {
                sp38 = temp_v0;
                func_800C9018(temp_s0 & 0xFF, 0x01008026);
            }
            sp38 = sp38;
            func_800C97C4(temp_s0 & 0xFF);
            *sp38 = 1;
            func_800C94A4(temp_s0 & 0xFF);
            temp_v0_2 = gCurrentCourseId;
            if (((temp_v0_2 == 1) || (temp_v0_2 == 2) || (temp_v0_2 == 3) || (temp_v0_2 == 4) || (temp_v0_2 == 5) || (temp_v0_2 == 6) || (temp_v0_2 == 7) || (temp_v0_2 == 0x000C) || (temp_v0_2 == 0x0012) || (temp_v0_2 == 0x0013)) && (*(&D_800EA0EC + temp_s0) == 0)) {
                temp_a1 = (temp_s0 * 0x3C) + &D_800E9F7C;
                play_sound((sp3C->characterId * 0x10) + 0x29008005, temp_a1, temp_s0 & 0xFF, &D_800EA1D4, &D_800EA1D4, temp_a1 + 0x14);
            }
        }
    } else {
        temp_v0_3 = temp_s0 + &D_800E9F74;
        if (*temp_v0_3 == 1) {
            sp38 = temp_v0_3;
            func_800C97C4(temp_s0 & 0xFF);
            *temp_v0_3 = 2;
            func_800C94A4(temp_s0 & 0xFF);
            *temp_v0_3 = 0;
            if ((gCurrentCourseId == 6) && (*(&D_800EA0EC + temp_s0) == 0)) {
                temp_a1_2 = (temp_s0 * 0x3C) + &D_800E9F7C;
                play_sound((sp3C->characterId * 0x10) + 0x29008008, temp_a1_2, temp_s0 & 0xFF, &D_800EA1D4, &D_800EA1D4, temp_a1_2 + 0x14);
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C847C.s")
#endif

void func_800C86D8(u8 playerId) {
    if (((gPlayers[playerId].unk_0BC & 0x40000000) != 0x40000000) && (D_800E9F24[playerId] == 1)) {
        func_800C90F4(playerId, (gPlayers[playerId].characterId * 0x10) + 0x29008008);
    }
}

void func_800C8770(u8 playerId) {
    if ((gPlayers[playerId].unk_0BC & 0x40000000) == 0x40000000) {
        D_800E9F24[playerId] = 1;
        if (D_800E9F2C[playerId] < 0xFA) {
            D_800E9F2C[playerId]++;
        }
    } else {
        D_800E9F2C[playerId] = 0;
        if (D_800E9F24[playerId] == 1) {
            D_800E9F24[playerId] = 2;
        }
    }
    switch (D_800E9F24[playerId]) {                               /* irregular */
    case 1:
        if (D_800E9F34[playerId] < 0.7f) {
            D_800E9F34[playerId] += 0.1f;
            D_800E9F54[playerId] += 0.03f;
        }
        break;
    case 2:
        if (D_800E9F34[playerId] > 0.16f) {
            D_800E9F34[playerId] -= 0.15f;
            D_800E9F54[playerId] -= 0.03f;
        } else {
            D_800E9F34[playerId] = 0.0f;
            D_800E9F54[playerId] = 0.0f;
            D_800E9F24[playerId] = 0;
        }
        break;
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800CAC08(); // extern
extern u8 D_800EA168;
extern Player gPlayers;

void func_800C8920(void) {
    if ((D_800EA168 != 0) && ((gPlayers.unkBC & 0x40000000) != 0x40000000) && ((gPlayers.unkE94 & 0x40000000) != 0x40000000) && ((gPlayers.unk1C6C & 0x40000000) != 0x40000000) && ((gPlayers.unk2A44 & 0x40000000) != 0x40000000) && ((gPlayers.unk381C & 0x40000000) != 0x40000000) && ((gPlayers.unk45F4 & 0x40000000) != 0x40000000) && ((gPlayers.unk53CC & 0x40000000) != 0x40000000) && ((gPlayers.unk61A4 & 0x40000000) != 0x40000000)) {
        func_800CAC08();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C8920.s")
#endif

void func_800C89E4(void) {
    if (D_800EA180 != 0) {
        D_800EA180++;
        if (D_800EA180 == 2) {
            D_800EA17C = 1.0f;
        }
        if (D_800EA180 < 0xF) {
            D_800EA178 = 1.0f - (D_800EA180 * 0.012f);
        }
        if ((D_800EA180 >= 0x33) && (D_800EA180 < 0x96)) {
            D_800EA17C = 1.0f - ((D_800EA180 - 0x32) / 110.0f);
        }
        if (D_800EA180 == 0x12D) {
            D_800EA17C = 0.0f;
        }
        if (D_800EA180 == 0x321) {
            D_800EA178 = 1.0f;
            D_800EA17C = 0.85f;
            D_800EA180 = 0;
        }
    }
}

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
static ? D_800E9F7C;                                /* unable to generate initializer; const */
static u8 D_800EA16C = 0;                           /* const */
static u16 D_800EA184 = 0;                          /* const */
static u8 D_800EA1C0 = 0;                           /* const */
s16 gCurrentCourseId;                               /* unable to generate initializer */

void func_800C8AE4(void) {
    u16 temp_t8;
    u16 var_v0;
    u8 temp_v0;

    if (gCurrentCourseId == 8) {
        var_v0 = D_800EA184;
        if (var_v0 != 0) {
            temp_t8 = var_v0 + 1;
            if (D_800EA16C == 0) {
                D_800EA184 = temp_t8;
                var_v0 = temp_t8 & 0xFFFF;
            }
            if (var_v0 == 0x012C) {
                D_800EA17C = 0.85f;
                D_800EA184 = 0;
            }
        } else {
            temp_v0 = D_800EA1C0;
            switch (temp_v0) {                      /* irregular */
            case 0:
                if (D_800E9F7C.unk14 != 0) {
                    D_800EA17C = 0.0f;
                    D_800EA184 = 1;
                    return;
                }
                break;
            case 1:
                if ((D_800E9F7C.unk14 != 0) || (D_800E9F7C.unk50 != 0)) {
                    D_800EA17C = 0.0f;
block_25:
                    D_800EA184 = 1;
                }
                break;
            case 2:
                if ((D_800E9F7C.unk14 != 0) || (D_800E9F7C.unk50 != 0) || (D_800E9F7C.unk8C != 0)) {
                    D_800EA17C = 0.0f;
                    D_800EA184 = 1;
                    return;
                }
                break;
            case 3:
                if ((D_800E9F7C.unk14 != 0) || (D_800E9F7C.unk50 != 0) || (D_800E9F7C.unk8C != 0) || (D_800E9F7C.unkC8 != 0)) {
                    D_800EA17C = 0.0f;
                    goto block_25;
                }
                break;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C8AE4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800E9F54;
extern ? D_800EA06C;
extern ? D_800EA130;

void func_800C8C7C(s32 arg0) {
    s32 temp_t6;
    s32 temp_v0;

    temp_t6 = arg0 & 0xFF;
    temp_v0 = temp_t6 * 4;
    *(&D_800EA06C + 8 + (temp_t6 * 0x10)) = (1.0f - *(&D_800E9F54 + temp_v0)) - *(&D_800EA130 + temp_v0);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C8C7C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C5D04(s32); // extern
void func_800C5E38(s32); // extern
void func_800C6108(s32); // extern
void func_800C64A0(s32); // extern
void func_800C6758(s32); // extern
void func_800C683C(s32); // extern
void func_800C70A8(s32); // extern
void func_800C76C0(s32); // extern
void func_800C847C(s32); // extern
void func_800C86D8(s32); // extern
void func_800C8770(s32); // extern
void func_800C8920(); // extern
void func_800C89E4(); // extern
void func_800C8AE4(); // extern
void func_800C8C7C(s32); // extern
extern u8 D_800EA1C0;

void func_800C8CCC(void) {
    s32 temp_t6;
    s32 temp_t8;
    s32 temp_t9;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 phi_s0;
    s32 phi_s0_2;
    s32 phi_v0;
    s32 phi_s0_3;

    temp_v0 = D_800EA1C0 + 1;
    phi_s0 = 0;
    phi_v0 = temp_v0;
    if (temp_v0 > 0) {
        do {
            func_800C5D04(phi_s0 & 0xFF);
            func_800C5E38(phi_s0 & 0xFF);
            func_800C6108(phi_s0 & 0xFF);
            func_800C64A0(phi_s0 & 0xFF);
            func_800C6758(phi_s0 & 0xFF);
            func_800C683C(phi_s0 & 0xFF);
            func_800C70A8(phi_s0 & 0xFF);
            func_800C76C0(phi_s0 & 0xFF);
            func_800C847C(phi_s0 & 0xFF);
            func_800C86D8(phi_s0 & 0xFF);
            temp_t6 = (phi_s0 + 1) & 0xFF;
            temp_v0_2 = D_800EA1C0 + 1;
            phi_s0 = temp_t6;
            phi_v0 = temp_v0_2;
        } while (temp_t6 < temp_v0_2);
    }
    phi_s0_2 = 0;
    phi_s0_3 = 0;
    if (gModeSelection == GRAND_PRIX) {
        do {
            func_800C8770(phi_s0_2 & 0xFF);
            func_800C8C7C(phi_s0_2 & 0xFF);
            temp_t8 = (phi_s0_2 + 1) & 0xFF;
            phi_s0_2 = temp_t8;
        } while (temp_t8 < 8);
    } else if (phi_v0 > 0) {
        do {
            func_800C8770(phi_s0_3 & 0xFF);
            func_800C8C7C(phi_s0_3 & 0xFF);
            temp_t9 = (phi_s0_3 + 1) & 0xFF;
            phi_s0_3 = temp_t9;
        } while (temp_t9 < (D_800EA1C0 + 1));
    }
    func_800C8920();
    func_800C89E4();
    func_800C8AE4();
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C8CCC.s")
#endif

void play_sound2(s32 soundBits) {

    if ((soundBits == SOUND_ACTION_REV_ENGINE) && (gCurrentCourseId == 0x12)) {
        soundBits = 0x49008027;
    }

    if ((soundBits == SOUND_ACTION_REV_ENGINE_2) && (gCurrentCourseId == 0x12)) {
        soundBits = 0x49008028;
    }
    play_sound(soundBits, &D_800EA1C8, 4, &D_800EA1D4, &D_800EA1D4, &D_800EA1DC);
}

void func_800C8EAC(u16 arg0) {
    func_800C3448(arg0 | 0x10000);
    D_800EA15C = arg0;
}

void func_800C8EF8(u16 arg0) {
    func_800C3448(arg0 | 0x1010000);
    D_800EA160 = arg0;
}

void func_800C8F44(u8 arg0) {
    func_800C36C4(0, 0, arg0, 1);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void play_sound(s32, void *, s32, ? *, ? *, ? *); // extern
extern ? D_800E9F7C;
extern ? D_800EA0EC;
extern u8 D_800EA108;
extern ? D_800EA1D4;
extern ? D_800EA1DC;

void func_800C8F80(s32 arg0, s32 arg1) {
    s32 temp_a2;
    u8 *temp_v1;
    u8 temp_v0;

    temp_a2 = arg0 & 0xFF;
    if (D_800EA108 == 0) {
        temp_v1 = temp_a2 + &D_800EA0EC;
        temp_v0 = *temp_v1;
        if (temp_v0 != 0) {
            if (temp_v0 == 2) {
                *temp_v1 = 1;
                goto block_4;
            }
        } else {
block_4:
            play_sound(arg1, (temp_a2 * 0x3C) + &D_800E9F7C, temp_a2, &D_800EA1D4, &D_800EA1D4, &D_800EA1DC);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C8F80.s")
#endif

#ifdef NON_MATCHING
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
//void func_800C5578(void *, s32); // extern

typedef struct {
    s32 unk0[0x3C];
} UnkStruct_800E9F7C;

extern UnkStruct_800E9F7C D_800E9F7C[];

void func_800C9018(u8 arg0, s32 arg1) {
    //s32 temp_a2;

    //temp_a2 = arg0;
    func_800C5578(D_800E9F7C->unk0[arg0], arg1);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C9018.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void play_sound(s32, void *, s32, ? *, ? *, void *); // extern
extern ? D_800E9F7C;
extern ? D_800EA0EC;
extern u8 D_800EA108;
extern ? D_800EA1D4;

void func_800C9060(s32 arg0, s32 arg1) {
    s32 temp_a2;
    u8 *temp_v1;
    u8 temp_v0;
    void *temp_a1;

    temp_a2 = arg0 & 0xFF;
    if (D_800EA108 == 0) {
        temp_v1 = temp_a2 + &D_800EA0EC;
        temp_v0 = *temp_v1;
        if (temp_v0 != 0) {
            if (temp_v0 == 2) {
                *temp_v1 = 1;
                goto block_4;
            }
        } else {
block_4:
            temp_a1 = (temp_a2 * 0x3C) + &D_800E9F7C;
            play_sound(arg1, temp_a1, temp_a2, &D_800EA1D4, &D_800EA1D4, temp_a1 + 0x14);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C9060.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void play_sound(s32, void *, s32, ? *, ? *, void *); // extern
extern ? D_800E9F2C;
extern ? D_800E9F7C;
extern ? D_800EA0EC;
extern u8 D_800EA108;
extern ? D_800EA150;
extern s16 D_800EA180;
extern ? D_800EA1D4;
extern Player gPlayers;

void func_800C90F4(s32 arg0, s32 arg1) {
    s32 temp_a2;
    s32 temp_t9;
    u8 *temp_v1;
    u8 temp_v0;
    void *temp_a1;
    void *temp_a1_2;

    temp_a2 = arg0 & 0xFF;
    if (D_800EA108 == 0) {
        temp_v1 = temp_a2 + &D_800EA0EC;
        temp_v0 = *temp_v1;
        if (temp_v0 != 0) {
            if (temp_v0 == 2) {
                *temp_v1 = 1;
                goto block_4;
            }
            // Duplicate return node #12. Try simplifying control flow for better match
            return;
        }
block_4:
        temp_t9 = arg1 & ~0xF0;
        if ((temp_t9 == 0x29008003) || (temp_t9 == 0x29008004) || (temp_t9 == 0x29008005)) {
            D_800EA180 = 1;
        }
        if (((*(&gPlayers + 0xBC + (temp_a2 * 0xDD8)) & 0x40000000) == 0x40000000) && (*(&D_800E9F2C + temp_a2) >= 0x1F)) {
            temp_a1 = (temp_a2 * 0x3C) + &D_800E9F7C;
            play_sound(arg1, temp_a1, temp_a2, &D_800EA150, &D_800EA1D4, temp_a1 + 0x14);
            return;
        }
        temp_a1_2 = (temp_a2 * 0x3C) + &D_800E9F7C;
        play_sound(arg1, temp_a1_2, temp_a2, &D_800EA1D4, &D_800EA1D4, temp_a1_2 + 0x14);
        // Duplicate return node #12. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C90F4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C90F4(s32, s32); // extern
extern s32 gAudioRandom;
extern Player gPlayers;

void func_800C9250(s32 arg0) {
    s32 temp_t6;

    temp_t6 = arg0 & 0xFF;
    func_800C90F4(temp_t6, (*(&gPlayers + 0x254 + (temp_t6 * 0xDD8)) * 0x10) + (gAudioRandom & 1) + 0x29008001);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C9250.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
static ? D_800E9F2C;                                /* unable to generate initializer; const */
static ? D_800EA06C;                                /* unable to generate initializer; const */
static u8 D_800EA0F0 = 0;                           /* const */
static u8 D_800EA1C0 = 0;                           /* const */
s8 D_800EA108 = 0;                                  /* const */

void func_800C92CC(s32 playerId, u32 soundBits) {
    f32 *sp68;
    f32 *sp64;
    Player *temp_s1;
    f32 *temp_t0;
    s32 temp_s4;
    s32 temp_t3;
    s32 var_s0;
    struct Unk_8018EFD8 *temp_v0_2;
    u8 temp_v0;

    temp_s4 = playerId & 0xFF;
    if (((u8) D_800EA108 == 0) && (D_800EA0F0 == 0)) {
        temp_v0 = D_800EA1C0;
        if ((s32) temp_v0 < 2) {
            var_s0 = 0;
            if ((s32) temp_v0 >= 0) {
                temp_s1 = &gPlayers[temp_s4];
                sp64 = temp_s1->unk_034;
                sp68 = temp_s1->pos;
                do {
                    temp_v0_2 = func_800C1C88(temp_s4 & 0xFF, sp68, sp64, &D_800EA1C8, (u8) var_s0, soundBits);
                    if (temp_v0_2 != NULL) {
                        temp_v0_2->unk34 = 170.0f;
                        temp_t0 = (temp_s4 * 0x10) + 0xC + &D_800EA06C;
                        if (((temp_s1->unk_0BC & 0x40000000) == 0x40000000) && ((s32) *(&D_800E9F2C + temp_s4) >= 0x1F)) {
                            play_sound((temp_s1->characterId * 0x10) + soundBits, temp_v0_2->unk18, var_s0 & 0xFF, &D_800EA150, &D_800EA1D4, temp_t0);
                        } else {
                            play_sound((temp_s1->characterId * 0x10) + soundBits, temp_v0_2->unk18, var_s0 & 0xFF, &temp_v0_2->unk2C, &D_800EA1D4, temp_t0);
                        }
                    }
                    temp_t3 = (var_s0 + 1) & 0xFF;
                    var_s0 = temp_t3;
                } while (temp_t3 < (D_800EA1C0 + 1));
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C92CC.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
static ? D_800E9F74;                                /* unable to generate initializer; const */
static ? D_800E9F7C;                                /* unable to generate initializer; const */
static ? D_800EA0EC;                                /* unable to generate initializer; const */
u8 D_800EA108 = 0;                                  /* const */
u8 D_800EA1C0 = 0;                                  /* const */

void func_800C94A4(u8 playerId) {
    f32 *temp_a1;
    f32 var_f6;
    u16 temp_v1_2;
    u32 var_a0;
    u8 *temp_v1;
    u8 temp_a2;
    u8 temp_v0;
    u8 temp_v0_2;

    temp_a2 = playerId & 0xFF;
    if (D_800EA108 == 0) {
        temp_v1 = temp_a2 + &D_800EA0EC;
        temp_v0 = *temp_v1;
        if (temp_v0 != 0) {
            if (temp_v0 == 2) {
                *temp_v1 = 1;
                goto block_4;
            }
        } else {
block_4:
            temp_a1 = (temp_a2 * 0x3C) + &D_800E9F7C;
            temp_a1->unkC = 1.0f;
            temp_a1->unk10 = 0.0f;
            temp_v1_2 = *(&gPlayers->characterId + (temp_a2 * 0xDD8));
            switch (temp_v1_2) {
            case 0:
            case 1:
                temp_a1->unk18 = 2.8f;
                temp_a1->unk20 = 0.35f;
                temp_a1->unk1C = 3844.0f;
                temp_a1->unk28 = 0.35f;
                temp_a1->unk24 = -0.8f;
                temp_a1->unk2C = 1568.9796f;
                temp_a1->unk30 = 1067.7778f;
                var_f6 = 2766.065f;
block_11:
                temp_a1->unk34 = var_f6;
                break;
            case 2:
            case 6:
                temp_a1->unk18 = 3.2f;
                temp_a1->unk20 = 0.6f;
                temp_a1->unk1C = 3844.0f;
                temp_a1->unk28 = 0.6f;
                temp_a1->unk24 = -1.7f;
                temp_a1->unk2C = 1478.4615f;
                temp_a1->unk30 = 784.4898f;
                var_f6 = 12813.335f;
                goto block_11;
            case 3:
                temp_a1->unk18 = 2.8f;
                temp_a1->unk20 = 0.6f;
                temp_a1->unk1C = 3844.0f;
                temp_a1->unk28 = 0.6f;
                temp_a1->unk24 = -0.6f;
                temp_a1->unk2C = 1747.2728f;
                temp_a1->unk30 = 1130.5883f;
                var_f6 = 3844.001f;
                goto block_11;
            case 4:
                temp_a1->unk18 = 2.0f;
                temp_a1->unk20 = 0.2f;
                temp_a1->unk1C = 3844.0f;
                temp_a1->unk28 = 0.2f;
                temp_a1->unk24 = -0.4f;
                temp_a1->unk2C = 2135.5557f;
                temp_a1->unk30 = 1601.6666f;
                var_f6 = 3203.333f;
                goto block_11;
            case 5:
            case 7:
                temp_a1->unk18 = 2.4f;
                temp_a1->unk20 = 0.4f;
                temp_a1->unk1C = 3844.0f;
                temp_a1->unk28 = 0.4f;
                temp_a1->unk24 = -0.8f;
                temp_a1->unk2C = 1922.0f;
                temp_a1->unk30 = 1201.25f;
                var_f6 = 4805.0f;
                goto block_11;
            }
            temp_v0_2 = *(&D_800E9F74 + temp_a2);
            var_a0 = temp_v1_2 + 0x0104FF00;
            switch (temp_v0_2) {                    /* switch 1; irregular */
            case 0:                                 /* switch 1 */
                if (D_800EA1C0 != 0) {
                    var_a0 += 0x14;
                }
                break;
            case 1:                                 /* switch 1 */
                var_a0 += 0x2E;
                break;
            case 2:                                 /* switch 1 */
                if (D_800EA1C0 == 0) {
                    var_a0 += 0x36;
                } else {
                    var_a0 += 0x3E;
                }
                break;
            }
            play_sound(var_a0, temp_a1, temp_a2, temp_a1 + 0xC, temp_a1 + 0x10, temp_a1 + 0x14);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C94A4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C5578(void *, s32, s32); // extern
extern ? D_800E9F7C;
extern Player gPlayers;

void func_800C97C4(s32 arg0) {
    s32 temp_a2;
    void *temp_s0;
    void *temp_s1;

    temp_a2 = arg0 & 0xFF;
    temp_s1 = (temp_a2 * 0xDD8) + &gPlayers;
    temp_s0 = (temp_a2 * 0x3C) + &D_800E9F7C;
    func_800C5578(temp_s0, temp_s1->unk254 + 0x104FF00, temp_a2);
    func_800C5578(temp_s0, temp_s1->unk254 + 0x104FF14);
    func_800C5578(temp_s0, temp_s1->unk254 + 0x104FF2E);
    func_800C5578(temp_s0, temp_s1->unk254 + 0x104FF36);
    func_800C5578(temp_s0, temp_s1->unk254 + 0x104FF3E);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C97C4.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
static u8 D_800EA1DC = 0;                           /* const */
u8 D_800EA0F0 = 0;                                  /* const */
u8 D_800EA108 = 0;                                  /* const */
u8 D_800EA1C0 = 0;                                  /* const */
f32 D_800EA1C8[3] = { 0.0f, 0.0f, 0.0f };           /* const */

void func_800C98B8(f32 *position, f32 *velocity, u32 soundBits) {
    s32 temp_t0;
    s32 var_s0;
    struct Unk_8018EFD8 *temp_v0;

    if ((D_800EA108 == 0) && (D_800EA0F0 == 0)) {
        var_s0 = 0;
        if ((D_800EA1C0 + 1) > 0) {
            do {
                temp_v0 = func_800C1C88(0U, position, velocity, D_800EA1C8, (u8) var_s0, soundBits);
                if (temp_v0 != NULL) {
                    temp_v0->unk34 = 170.0f;
                    play_sound(soundBits, temp_v0->unk18, var_s0 & 0xFF, &temp_v0->unk2C, &D_800EA1D4, &D_800EA1DC);
                }
                temp_t0 = (var_s0 + 1) & 0xFF;
                var_s0 = temp_t0;
            } while (temp_t0 < (D_800EA1C0 + 1));
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C98B8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800C21E8(s32, ?); // extern
void func_800C5578(s32, ?); // extern
extern u8 D_800EA108;
extern u8 D_800EA1C0;

void func_800C99E0(Vec3f arg0, s32 arg1) {
    s32 temp_t9;
    s32 temp_v0;
    s32 phi_s0;

    if (D_800EA108 == 0) {
        phi_s0 = 0;
        if ((D_800EA1C0 + 1) > 0) {
            do {
                temp_v0 = func_800C21E8(arg0, arg1);
                if (temp_v0 != 0) {
                    func_800C5578(temp_v0, arg1);
                }
                temp_t9 = (phi_s0 + 1) & 0xFF;
                phi_s0 = temp_t9;
            } while (temp_t9 < (D_800EA1C0 + 1));
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C99E0.s")
#endif

void func_800C9A88(u8 playerId) {
    u8 var_s0;
    u32 soundBits;
    struct Unk_8018EFD8 *temp_v0_6;

    if (D_800EA108 == 0) {
        switch(D_800EA0F0) {
        case 2:
            D_800EA0F0 = 1;
            /* fallthrough */
        case 0:
            switch (gPlayers[playerId].characterId) {
            case 0:
            case 1:
                D_800EA06C[playerId].unk00[0] = 0.35f;
                D_800EA06C[playerId].unk00[1] = 1568.9796f;
                break;
            case 2:
            case 6:
                D_800EA06C[playerId].unk00[0] = 0.6f;
                D_800EA06C[playerId].unk00[1] = 1478.4615f;
                break;
            case 3:
                D_800EA06C[playerId].unk00[0] = 0.6f;
                D_800EA06C[playerId].unk00[1] = 1747.2728f;
                break;
            case 4:
                D_800EA06C[playerId].unk00[0] = 0.2f;
                D_800EA06C[playerId].unk00[1] = 2135.5557f;
                break;
            case 5:
            case 7:
                D_800EA06C[playerId].unk00[0] = 0.4f;
                D_800EA06C[playerId].unk00[1] = 1922.0f;
            }
            if (D_800EA1C0 < 2) {
                for (var_s0 = 0; var_s0 < D_800EA1C0 + 1; var_s0++) {
                    soundBits = gPlayers[playerId].characterId + 0x31028000;
                    temp_v0_6 = func_800C1C88(playerId, gPlayers[playerId].pos, gPlayers[playerId].unk_034, &gPlayers[playerId].unk_098, var_s0, soundBits);
                    if (temp_v0_6 != NULL) {
                        temp_v0_6->unk34 = 40.0f;
                        play_sound(soundBits, temp_v0_6->unk18, var_s0, &temp_v0_6->unk2C, &D_800EA06C[playerId].unk00[2], &D_800EA06C[playerId].unk0C);
                    }
                }
            }
            break;
        default:
            break;
        }
    }
}

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
? func_800C550C(f32 *);                             /* extern */

void func_800C9D0C(s32 playerId) {
    Player *temp_v0;

    temp_v0 = &gPlayers[playerId & 0xFF];
    func_800C550C(func_800C21E8(temp_v0->pos, temp_v0->characterId + 0x31028000));
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C9D0C.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
static u8 D_800EA0F0 = 0;                           /* const */
static u8 D_800EA1C0 = 0;                           /* const */
s8 D_800EA108 = 0;                                  /* const */

void func_800C9D80(Vec3f position, Vec3f velocity, u32 soundBits) {
    s32 temp_t8;
    s32 var_s0;
    struct Unk_8018EFD8 *temp_v0_2;
    u8 temp_v0;

    if (((u8) D_800EA108 == 0) && (D_800EA0F0 == 0)) {
        temp_v0 = D_800EA1C0;
        if ((s32) temp_v0 < 4) {
            var_s0 = 0;
            if ((s32) temp_v0 >= 0) {
                do {
                    temp_v0_2 = func_800C1C88(0U, position, velocity, &D_800EA1C8, (u8) var_s0, soundBits);
                    if (temp_v0_2 != NULL) {
                        temp_v0_2->unk34 = 170.0f;
                        if (soundBits == 0x5103700B) {
                            play_sound(soundBits, temp_v0_2->unk18, var_s0 & 0xFF, &D_800EA178, &D_800EA17C, &D_800EA1DC);
                        } else {
                            play_sound(soundBits, temp_v0_2->unk18, var_s0 & 0xFF, &temp_v0_2->unk2C, &D_800EA1D4, &D_800EA1DC);
                        }
                    }
                    temp_t8 = (var_s0 + 1) & 0xFF;
                    var_s0 = temp_t8;
                } while (temp_t8 < (D_800EA1C0 + 1));
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800C9D80.s")
#endif

void func_800C9EF4(Vec3f arg0, u32 arg1) {
    f32 *temp;
    u8 i;

    for (i = 0; i < D_800EA1C0 + 1; i++) {
        temp = func_800C21E8(arg0, arg1); 
        if (temp != NULL) {
            func_800C5578(temp, arg1);
        }
    }
}

void func_800C9F90(u8 arg0) {
    if ((arg0) != 0) {
        play_sound2(SOUND_ACTION_GO_BACK_2);
        func_800CBBB8(0xF1000000, 0);
        D_800EA16C = 1;
    } else {
        play_sound2(SOUND_ACTION_UNKNOWN_CONFIRMATION);
        func_800CBBB8(0xF2000000, 0);
        D_800EA16C = 0;
    }
}

void func_800CA008(u8 arg0, u8 arg1) {
   // u8 phi_v0;

    func_800C36C4(0, 0, 0x7F, 1);
    func_800C36C4(1, 0, 0x7F, 1);
    //phi_v0 = arg1;
    if (arg1 >= 4) {
        if ((arg1 == 0xC) || (arg1 == 4)) {
            arg1 = 5;
        } else {
            arg1 = 4;
        }
    }
    func_800C3448((arg0 << 8) | 0xF0000000 | arg1);
}

// With -framepointer active, you CANNOT put void
// in the argument list, causes a minor stack difference
void func_800CA0A0() {
    D_800EA108 = 1;
}

void func_800CA0B8() {
    D_800EA108 = 0;
}

void func_800CA0CC() {
    D_800EA108 = 1;
}

void func_800CA0E4(void) {
    func_800C5278(3);
    func_800C5278(5);
}

#ifdef MIPS_TO_C
    switch(D_800EA1C0) {
        case 0:
            D_800EA0F0 = 1;
            func_800CA0E4(&D_800EA0EC, 1);
            break;
        case 1:
            if ((D_800EA0EC.unk0 == 1) && (D_800EA0EC.unk1 == 1)) {
                D_800EA0F0 = 1;
                func_800CA0E4(&D_800EA0EC, 1);
            }
            break;
        case 2:
            if ((D_800EA0EC.unk0 == 1) && (D_800EA0EC.unk1 == 1) && (D_800EA0EC.unk2 == 1)) {
                D_800EA0F0 = 1;
                func_800CA0E4(&D_800EA0EC, 1);
            }
            break;
        case 3:
            if ((D_800EA0EC.unk0 == 1) && (D_800EA0EC.unk1 == 1) && (D_800EA0EC.unk2 == 1) && (D_800EA0EC.unk3 == 1)) {
                D_800EA0F0 = 1;
                func_800CA0E4(&D_800EA0EC, 1);
            }
            break;
    }
}


//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800CA0E4(? *, s8); // extern
extern ? D_800E9EA4;
extern ? D_800EA0EC;
extern s8 D_800EA0F0;
extern u8 D_800EA1C0;

void func_800CA118(s32 arg0) {
    s32 temp_t6;
    u8 temp_v0;

    temp_t6 = arg0 & 0xFF;
    *(&D_800EA0EC + temp_t6) = 1;
    temp_v0 = D_800EA1C0;
    *(&D_800E9EA4 + (temp_t6 * 4)) = 1;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                if ((D_800EA0EC.unk0 == 1) && (D_800EA0EC.unk1 == 1) && (D_800EA0EC.unk2 == 1) && (D_800EA0EC.unk3 == 1)) {
                    D_800EA0F0 = 1;
                    func_800CA0E4(&D_800EA0EC, 1);
                }
                // Duplicate return node #18. Try simplifying control flow for better match
                return;
            }
            if ((D_800EA0EC.unk0 == 1) && (D_800EA0EC.unk1 == 1) && (D_800EA0EC.unk2 == 1)) {
                D_800EA0F0 = 1;
                func_800CA0E4(&D_800EA0EC, 1);
                return;
            }
            // Duplicate return node #18. Try simplifying control flow for better match
            return;
        }
        if ((D_800EA0EC.unk0 == 1) && (D_800EA0EC.unk1 == 1)) {
            D_800EA0F0 = 1;
            func_800CA0E4(&D_800EA0EC, 1);
            return;
        }
        return;
    }
    D_800EA0F0 = 1;
    func_800CA0E4(&D_800EA0EC, 1);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CA118.s")
#endif

void func_800CA24C(u8 arg0) {
    D_800EA0EC[arg0] = 2;
}

void func_800CA270() {
    D_800EA0F4 = 1;
}

// appears to write u8 in list of f32s?
// However, 0x3C is 0.0f which could likely get confused with `u8 = 0`;
void func_800CA288(u8 arg0, s8 arg1) {
    D_800E9F90[arg0 * 0x3C] = arg1; // * 0x3C
}

void func_800CA2B8(u8 arg0) {
    D_800E9F90[arg0 * 0x3C] = 0;
}

void func_800CA2E4(u8 arg0, s8 arg1) {
    D_800EA06C[arg0].unk0C = arg1;
}

void func_800CA30C(u8 arg0) {
    D_800EA06C[arg0].unk0C = 0;
}

void func_800CA330(u8 arg0) {
    func_800C3448(arg0 << 0x10 | 0x100000FF);
    func_800C3448(arg0 << 0x10 | 0x110000FF);
}

void func_800CA388(u8 arg0) {
    arg0 *= 2;
    func_800C58B8(0, 0, arg0);
    func_800C58B8(1, 0, arg0);
    func_800C58B8(2, 0, arg0);
    func_800C58B8(3, 0, arg0);
    func_800C58B8(5, 0, arg0);
}

void func_800CA414(u16 arg0, u16 arg1) {
    if (D_800EA104 == 0) {
        func_800C3448(func_800C3508(0) | 0x30000000);
        func_800C35E8(0);
        func_800C3448(arg1 | 0xC1510000);
        func_800C3448(arg0 | 0x1000000);
    }
    D_800EA104 = 1;
}

void func_800CA49C(u8 arg0) {
    if (D_800EA108 == 0) {
        if (D_800EA1C0 >= 2) {
            func_800C9060(arg0, 0x1900FF3A);
        } else if (D_800EA164 != 0) {
            func_800C3448(0x100100FF); // 0x19000000
            func_800C3448(0x110100FF);
            func_800C8EF8(0xC);
            func_800C3448(0xC1510011);
        } else {
            func_800C3448(0x100100FF); //0x19000000
            func_800C3448(0x110100FF);
            func_800C8EF8(0xC);
            func_800C3448(D_800EA15C | 0xC1500000);
            func_800C3448(0xC130017D);
        }
        D_8018FC08 = D_8018FC08 + 1;
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C3448(?); // extern
s32 func_800C3508(?, ?); // extern
s32 func_800C357C(?); // extern
void func_800C8EF8(?, ?); // extern
void func_800C8F80(u8, ?); // extern
void play_sound(s32, void *, u8, ? *, ? *, void *); // extern
extern ? D_800E9F7C;
extern ? D_800EA0EC;
extern u8 D_800EA104;
extern u8 D_800EA108;
extern ? D_800EA10C;
extern s8 D_800EA164;
extern u8 D_800EA1C0;
extern ? D_800EA1D4;
extern u8 D_8018FC08;
extern Player gPlayers;

void func_800CA59C(u8 arg0) {
    u8 temp_a2;
    void *temp_a1;

    temp_a2 = arg0 & 0xFF;
    if ((*(&D_800EA0EC + temp_a2) == 0) && (D_800EA108 == 0)) {
        temp_a1 = (temp_a2 * 0x3C) + &D_800E9F7C;
        arg0 = temp_a2;
        play_sound((*(&gPlayers + 0x254 + (temp_a2 * 0xDD8)) * 0x10) + 0x29008001, temp_a1, temp_a2, &D_800EA1D4, &D_800EA1D4, temp_a1 + 0x14);
        D_800EA164 = 1;
        if (D_800EA1C0 >= 2) {
            func_800C8F80(arg0, 0x100FF2C);
        } else {
            func_800C3448(0x100100FF);
            if (D_800EA104 != 0) {
                func_800C8F80(arg0, 0x100FF2C);
            } else if (D_8018FC08 != 0) {
                if ((func_800C3508(1, 0x100FF2C) == 0xC) || (func_800C357C(0x101000C) == 0)) {
                    func_800C3448(0xC1F00000);
                    func_800C3448(0xC1510011);
                } else {
                    func_800C8EF8(0x11);
                }
            } else {
                func_800C8EF8(0x11, 0x100FF2C);
            }
        }
        *(&D_800EA10C + arg0) = 1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CA59C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C3448(s32, ?, u8); // extern
s32 func_800C3508(?, ?, u8); // extern
s32 func_800C357C(?); // extern
void func_800C3608(?, ?, u8); // extern
void func_800C8EAC(u16); // extern
void func_800C9018(s32, ?, u8); // extern
void play_sound(s32, void *, u8, ? *, ? *, void *); // extern
extern ? D_800E9F7C;
extern ? D_800EA0EC;
extern u8 D_800EA104;
extern u8 D_800EA108;
extern ? D_800EA10C;
extern u16 D_800EA15C;
extern s8 D_800EA164;
extern u8 D_800EA1C0;
extern ? D_800EA1D4;
extern u8 D_8018FC08;
extern u32 D_803B1658;
extern Player gPlayers;

void func_800CA730(u8 arg0) {
    u8 *sp3C;
    u8 *temp_v1;
    u8 temp_a2;
    void *temp_a1;

    temp_a2 = arg0 & 0xFF;
    if (*(&D_800EA0EC + temp_a2) == 0) {
        temp_v1 = &D_800EA10C + temp_a2;
        if ((D_800EA108 == 0) && (*temp_v1 != 0)) {
            temp_a1 = (temp_a2 * 0x3C) + &D_800E9F7C;
            sp3C = temp_v1;
            arg0 = temp_a2;
            play_sound((*(&gPlayers + 0x254 + (temp_a2 * 0xDD8)) * 0x10) + 0x29008008, temp_a1, temp_a2, &D_800EA1D4, &D_800EA1D4, temp_a1 + 0x14);
            if (*sp3C != 0) {
                if (D_800EA1C0 >= 2) {
                    func_800C9018(arg0 & 0xFF, 0x100FF2C, arg0);
                } else {
                    *sp3C = 0;
                    if (D_800EA104 != 0) {
                        func_800C9018(arg0 & 0xFF, 0x100FF2C, arg0);
                    } else if ((D_800EA10C.unk0 == 0) && (D_800EA10C.unk1 == 0)) {
                        if (D_8018FC08 != 0) {
                            if ((D_803B1658 >> 0x1F) == 0) {
                                func_800C3608(1, 5, arg0);
                                func_800C8EAC(D_800EA15C);
                                func_800C3448(0xB001307D);
                            } else if ((func_800C3508(1, 0x1000000, arg0) == 0xC) || (func_800C357C(0x101000C) == 0)) {
                                func_800C3448(0xC1F00000);
                                func_800C3448(D_800EA15C | 0xC1500000);
                                func_800C3448(0xC130017D);
                            } else {
                                func_800C3448(0x110100FF);
                                func_800C8EAC(D_800EA15C);
                                func_800C3448(0xB001307D);
                            }
                        } else {
                            func_800C3448(0x110100FF, 0x1000000, arg0);
                            func_800C8EAC(D_800EA15C);
                        }
                    }
                    D_800EA164 = 0;
                }
            }
            *sp3C = 0;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CA730.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 0927f17aac197848d4ebdf0c6bbad74b01f0851c
static u8 D_800EA0F0 = 0;                           /* const */
static u8 D_800EA1C0 = 0;                           /* const */
s8 D_800EA108 = 0;                                  /* const */

void func_800CA984(s32 arg0) {
    Player *temp_v0;
    s32 temp_s5;
    s32 temp_t2;
    s32 var_s0;
    struct Unk_8018EFD8 *temp_v0_2;

    temp_s5 = arg0 & 0xFF;
    if (((u8) D_800EA108 == 0) && (D_800EA0F0 == 0)) {
        var_s0 = 0;
        if ((D_800EA1C0 + 1) > 0) {
            temp_v0 = &gPlayers[temp_s5];
            do {
                temp_v0_2 = func_800C1C88(temp_s5 & 0xFF, temp_v0->pos, &D_800EA1C8, &temp_v0->unk_098, (u8) var_s0, 0x31029008U);
                if (temp_v0_2 != NULL) {
                    play_sound(SOUND_ITEM_STAR, temp_v0_2->unk18, var_s0 & 0xFF, &D_800EA1D4, &D_800EA1D4, &D_800EA1DC);
                }
                temp_t2 = (var_s0 + 1) & 0xFF;
                var_s0 = temp_t2;
            } while (temp_t2 < (D_800EA1C0 + 1));
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CA984.s")
#endif

void func_800CAACC(u8 playerId) {
    if ((u8) D_800EA108 == 0) {
        func_800C5578(func_800C21E8(gPlayers[playerId].pos, 0x31029008U), 0x31029008);
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C36C4(?, ?, ?, ?); // extern
void func_800C9060(u8, ?); // extern
void play_sound(?, ? *, ?, ? *, ? *, ? *); // extern
extern ? D_800EA0EC;
extern u8 D_800EA108;
extern s8 D_800EA168;
extern ? D_800EA1C8;
extern ? D_800EA1D4;
extern ? D_800EA1DC;

void func_800CAB4C(u8 arg0) {
    u8 *temp_v1;
    u8 temp_v0;

    if (D_800EA108 == 0) {
        temp_v1 = arg0 + &D_800EA0EC;
        temp_v0 = *temp_v1;
        if (temp_v0 != 0) {
            if (temp_v0 == 2) {
                *temp_v1 = 1;
                goto block_4;
            }
        } else {
block_4:
            func_800C36C4(0, 1, 0x55, 5);
            func_800C9060(arg0, 0x1900F013);
            play_sound(SOUND_ITEM_THUNDERBOLT, &D_800EA1C8, 0, &D_800EA1D4, &D_800EA1D4, &D_800EA1DC);
        }
        D_800EA168 = 1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CAB4C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C36C4(?, ?, ?, ?); // extern
void func_800C56F0(?); // extern
extern u8 D_800EA108;
extern s8 D_800EA168;

void func_800CAC08(void) {
    if (D_800EA108 == 0) {
        func_800C36C4(0, 1, 0x7F, 0x19);
        func_800C56F0(0x5101C00C);
        D_800EA168 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CAC08.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C36C4(?, ?, ?, ?); // extern
void play_sound(?, ? *, ?, ? *, ? *, ? *); // extern
extern u8 D_800EA0F0;
extern u8 D_800EA108;
extern ? D_800EA10C;
extern s8 D_800EA168;
extern ? D_800EA1C8;
extern ? D_800EA1D4;
extern ? D_800EA1DC;

void func_800CAC60(s32 arg0) {
    if ((D_800EA108 == 0) && (D_800EA0F0 == 0)) {
        play_sound(SOUND_ACTION_EXPLOSION_2, &D_800EA1C8, 0, &D_800EA1D4, &D_800EA1D4, &D_800EA1DC);
        if ((D_800EA10C.unk0 != 1) && (D_800EA10C.unk1 != 1)) {
            func_800C36C4(0, 1, 0x37, 5);
            play_sound(SOUND_ITEM_THUNDERBOLT, &D_800EA1C8, 0, &D_800EA1D4, &D_800EA1D4, &D_800EA1DC);
            D_800EA168 = 1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CAC60.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C36C4(?, ?, ?, ?); // extern
void func_800C56F0(?); // extern
extern u8 D_800EA108;
extern s8 D_800EA168;
extern ? D_800EA170;

void func_800CAD40(s32 arg0) {
    if (D_800EA108 == 0) {
        if ((D_800EA170.unk0 == 0) && (D_800EA170.unk1 == 0) && (D_800EA170.unk2 == 0) && (D_800EA170.unk3 == 0)) {
            func_800C36C4(0, 1, 0x7F, 0x19);
        }
        func_800C56F0(0x5101C00C);
        D_800EA168 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CAD40.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void play_sound(f32, ?, void *, s32, ? *, f32 *, void *); // extern
extern ? D_800E9F7C;
extern ? D_800EA0EC;
extern u8 D_800EA108;
extern ? D_800EA110;
extern ? D_800EA1D4;
extern f32 D_800F39A8;
extern f32 D_800F39AC;

void func_800CADD0(s32 arg0, f32 arg1) {
    f32 *temp_v0_2;
    f32 temp_f12;
    s32 temp_a2;
    u8 *temp_v1;
    u8 temp_v0;
    void *temp_a1;
    f32 phi_f12;
    f32 phi_f12_2;

    temp_a2 = arg0 & 0xFF;
    if (D_800EA108 == 0) {
        temp_v1 = temp_a2 + &D_800EA0EC;
        temp_v0 = *temp_v1;
        if (temp_v0 != 0) {
            if (temp_v0 == 2) {
                *temp_v1 = 1;
                goto block_4;
            }
        } else {
block_4:
            temp_f12 = (arg1 * D_800F39A8) + D_800F39AC;
            temp_a1 = (temp_a2 * 0x3C) + &D_800E9F7C;
            temp_v0_2 = (temp_a2 * 4) + &D_800EA110;
            phi_f12 = temp_f12;
            if (temp_f12 > 1.0f) {
                phi_f12 = 1.0f;
            }
            phi_f12_2 = phi_f12;
            if (phi_f12 < 0.0f) {
                phi_f12_2 = 0.0f;
            }
            *temp_v0_2 = phi_f12_2;
            play_sound(phi_f12_2, 0x1900A209, temp_a1, temp_a2, &D_800EA1D4, temp_v0_2, temp_a1 + 0x14);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CADD0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void play_sound(f32, s32, void *, s32, ? *, f32 *, void *); // extern
extern ? D_800E9F7C;
extern ? D_800EA0EC;
extern u8 D_800EA108;
extern ? D_800EA120;
extern ? D_800EA1D4;
extern f32 D_800F39B0;
extern f32 D_800F39B4;

void func_800CAEC4(s32 arg0, f32 arg1) {
    f32 *temp_v0_2;
    f32 temp_f12;
    s32 temp_a2;
    u8 *temp_v1;
    u8 temp_v0;
    void *temp_a1;
    f32 phi_f12;
    f32 phi_f12_2;

    temp_a2 = arg0 & 0xFF;
    if (D_800EA108 == 0) {
        temp_v1 = temp_a2 + &D_800EA0EC;
        temp_v0 = *temp_v1;
        if (temp_v0 != 0) {
            if (temp_v0 == 2) {
                *temp_v1 = 1;
                goto block_4;
            }
        } else {
block_4:
            temp_f12 = (arg1 * D_800F39B0) + D_800F39B4;
            temp_v0_2 = (temp_a2 * 4) + &D_800EA120;
            temp_a1 = (temp_a2 * 0x3C) + &D_800E9F7C;
            phi_f12 = temp_f12;
            if (temp_f12 > 1.0f) {
                phi_f12 = 1.0f;
            }
            phi_f12_2 = phi_f12;
            if (phi_f12 < 0.0f) {
                phi_f12_2 = 0.0f;
            }
            *temp_v0_2 = phi_f12_2;
            play_sound(phi_f12_2, gCurrentCourseId + 0x19007020, temp_a1, temp_a2, &D_800EA1D4, temp_v0_2, temp_a1 + 0x14);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CAEC4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C36C4(?, ?, ?, ?); // extern
void func_800C8F80(u8, ?); // extern
void func_800C9060(u8, ?); // extern
extern ? D_800EA0EC;
extern u8 D_800EA108;
extern ? D_800EA170;

void func_800CAFC0(u8 arg0) {
    u8 *temp_v1;
    u8 temp_v0;

    if (D_800EA108 == 0) {
        temp_v1 = arg0 + &D_800EA0EC;
        temp_v0 = *temp_v1;
        if (temp_v0 != 0) {
            if (temp_v0 == 2) {
                *temp_v1 = 1;
                goto block_4;
            }
        } else {
block_4:
            func_800C36C4(0, 1, 0x55, 5);
            func_800C9060(arg0, 0x19009E59);
            func_800C8F80(arg0, 0x100FA4C);
            *(&D_800EA170 + arg0) = 1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CAFC0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C36C4(?, ?, ?, ?); // extern
void func_800C9018(u8, ?); // extern
void func_800C90F4(u8, s32); // extern
extern u8 D_800EA108;
extern u8 D_800EA168;
extern ? D_800EA170;
extern Player gPlayers;

void func_800CB064(u8 arg0) {
    u8 *sp34;
    u8 *temp_t9;

    if (D_800EA108 == 0) {
        temp_t9 = arg0 + &D_800EA170;
        sp34 = temp_t9;
        if (*temp_t9 == 1) {
            if (D_800EA168 == 0) {
                func_800C36C4(0, 1, 0x7F, 0x19);
            }
            func_800C90F4(arg0, (*(&gPlayers + 0x254 + (arg0 * 0xDD8)) * 0x10) + 0x29008008);
            func_800C9018(arg0, 0x100FA4C);
            *sp34 = 0;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CB064.s")
#endif

void func_800CB134() {
    D_800EA174 = 1;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800C3448(?); // extern
void func_800C8EAC(?); // extern
void func_800C8EF8(?); // extern
extern u16 D_800EA174;

void func_800CB14C(void) {
    u16 temp_t6;
    u16 temp_v0;
    u16 temp_v1;
    u16 phi_v0;
    u16 phi_v0_2;
    u16 phi_v0_3;
    u16 phi_v0_4;
    u16 phi_v0_5;
    u16 phi_v0_6;
    u16 phi_v0_7;

    temp_v1 = D_800EA174;
    if (temp_v1 != 0) {
        temp_t6 = temp_v1 + 1;
        temp_v0 = temp_t6 & 0xFFFF;
        D_800EA174 = temp_t6;
        phi_v0 = temp_v0;
        if (temp_v0 == 3) {
            func_800C8EAC(0x1A);
            func_800C3448(0x4000007F);
            phi_v0 = D_800EA174;
        }
        phi_v0_2 = phi_v0;
        if (phi_v0 == 0x12C) {
            func_800C8EAC(0x1B);
            func_800C3448(0x4000007F);
            func_800C8EF8(0x1D);
            func_800C3448(0x41000000);
            phi_v0_2 = D_800EA174;
        }
        phi_v0_3 = phi_v0_2;
        if (phi_v0_2 == 0x230) {
            func_800C3448(0x40640000);
            func_800C3448(0xB0640073);
            func_800C3448(0x4150007F);
            func_800C3448(0xB1640073);
            phi_v0_3 = D_800EA174;
        }
        phi_v0_4 = phi_v0_3;
        if (phi_v0_3 == 0x2A8) {
            func_800C3448(0x100100FF);
            phi_v0_4 = D_800EA174;
        }
        phi_v0_5 = phi_v0_4;
        if (phi_v0_4 == 0x41A) {
            func_800C3448(0xB1500001);
            func_800C3448(0x51500001);
            phi_v0_5 = D_800EA174;
        }
        phi_v0_6 = phi_v0_5;
        if (phi_v0_5 == 0x46A) {
            func_800C3448(0x41320000);
            phi_v0_6 = D_800EA174;
        }
        phi_v0_7 = phi_v0_6;
        if (phi_v0_6 == 0x4B0) {
            func_800C3448(0x110100FF);
            phi_v0_7 = D_800EA174;
        }
        if (phi_v0_7 == 0x4CE) {
            func_800C8EAC(0x14);
            func_800C3448(0x4000007F);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CB14C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
//void func_800C1F8C(); // extern
//void func_800C2274(?); // extern
//void func_800C3478(); // extern
//void func_800C3724(); // extern
//void func_800C5848(); // extern
//void func_800C59C4(); // extern
//void func_800C8CCC(); // extern
//void func_800CBC24(); // extern

// run audio?
void func_800CB2C4(void) {
    func_800C1F8C();
    func_800C3724();
    func_800C3478();
    func_800C5848();
    func_800C59C4();
    func_800C8CCC();
    func_800C2274(0);
    func_800CBC24();
}
#else
GLOBAL_ASM("asm/non_matchings/audio/external/func_800CB2C4.s")
#endif
